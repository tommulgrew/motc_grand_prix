#include "gamedata"
#include "world"
#include "render"
#include "routines"
#include "gameconstants"

// Routines

void resetPlayer();
void initAICars();
void sortCars(float z);
void updatePlayer();
void updateAICars();
void updatePlayerRevs();
void updatePlayerSuspension();
void moveCar(Car car);
void doCarCollisions();

void initRace(Track track) {
    generateTrack(track);
    resetPlayer();
    initAICars();

    // Start looped engine soundeffects
    playsfx(gameSfx.engine1, 0, true);
    playsfx(gameSfx.engine2, 1, true, 0.4);
}

void updatePlayerInput() {
    CarInput input = player.input;

    // Acceleration
    input.accel = 0;
    if (keydn(KEY_UP)   or keydn("z") or btn(BTN_A)) input.accel += 1;
    if (keydn(KEY_DOWN) or keydn("x") or btn(BTN_B)) input.accel -= 1;
    input.accel += axis(AX_RTRIG);
    input.accel -= axis(AX_LTRIG);
    input.accel = clamp(input.accel, -1, 1);

    // Keyboard (or dpad) steering
    float sx = 0;
    if (keydn(KEY_LEFT)  or btn(BTN_LEFT))  sx -= 1;
    if (keydn(KEY_RIGHT) or btn(BTN_RIGHT)) sx += 1;
    if (sx != 0 and (input.keyboardSteering = 0 or sgn(sx) = sgn(input.keyboardSteering))) {
        // Turning wheel away from center
        sx *= 0.045;
        input.keyboardSteering += sx;
    }
    else {
        // Recentering
        float recenter = sx != 0 ? 0.08 : 0.02;
        if (abs(input.keyboardSteering) < recenter) {
            input.keyboardSteering = 0;
        }
        else {
            input.keyboardSteering -= sgn(input.keyboardSteering) * recenter;
        }
    }
    input.keyboardSteering = clamp(input.keyboardSteering, -1, 1);

    // Game controller analogue steering.
    // Apply deadzone, and smoothing.
    float axisx = axis(AX_X) * gameConfig.controllerFactor;
    if (abs(axisx) < gameConfig.controllerDeadzone) {
        axisx = 0;
    }
    else {
        axisx = sgn(axisx) * (abs(axisx) - gameConfig.controllerDeadzone) / (1 - gameConfig.controllerDeadzone);
    }
    input.controllerSteering = input.controllerSteering * gameConfig.controllerSmoothing + axisx * (1 - gameConfig.controllerSmoothing);
    input.controllerSteering = clamp(input.controllerSteering, -1, 1);
    if (abs(input.controllerSteering) < 0.01) input.controllerSteering = 0;

    // Steering
    input.steering = input.keyboardSteering + input.controllerSteering;
    input.steering = clamp(input.steering, -1, 1);
}

void updateGame() {
    updatePlayer();
    updateAICars();
    doCarCollisions();
    sortCars(player.pos.z);

    // Collision sfx timer
    if (collideSfxTimer > 0) {
        collideSfxTimer--;
    }
    else {
        collideSfxIndex = -1;
    }    
}

CarAIParams getBaseAIParams(float f) {
    DifficultyLevel difficulty = difficultyLevels[gameConfig.difficulty];
    f = clamp(f + difficulty.baseFactorOffset, 0.1, 1);
    return new CarAIParams {
        velocityFactor = lerp(difficulty.velocityFactorRange.min, difficulty.velocityFactorRange.max, f),
        maxVelocity = lerp(difficulty.maxVelocityRange.min / 600, difficulty.maxVelocityRange.max / 600, f),
        steeringSmoothing = difficulty.steeringSmoothing,
        wander = difficulty.wander,
        wanderPeriod = 400,
        lookAhead = difficulty.lookAhead
    };
}

CarAIParams getAIParams(CarAIParams base) {
    DifficultyLevel difficulty = difficultyLevels[gameConfig.difficulty];
    return new CarAIParams {
        velocityFactor = base.velocityFactor + rnd2(difficulty.velocityFactorVariance),
        maxVelocity = base.maxVelocity + rnd2(difficulty.maxVelocityVariance / 600),
        steeringSmoothing = min(base.steeringSmoothing + rnd2(difficulty.steeringSmoothingVariance), 0.2),
        wander = base.wander + rnd2(difficulty.wanderVariance),
        wanderPeriod = base.wanderPeriod + rnd2(100),
        lookAhead = base.lookAhead + rnd2(difficulty.lookAheadVariance)
    };
}

void resetPlayer() {
    player = new Car {
        name = "Player",
        pos = new Vec { 
            x = 1.5, 
            y = 0, 
            z = 0.0001 
        },
        anim = new CarAnimation {
            revs = 0.15
        },
        aiState = new CarAIState {
            wanderOffset = rnd(),
            baseAIParams = getBaseAIParams(0.75)
        },
        input = new CarInput,
        race = new CarRaceState
    };
    player.aiState.aiParams = player.aiState.baseAIParams;
}

void initAICars() {

    // Build AI car pool
    aiCarPool = new Car[0];
    for (int i = 0; i < aiCarNames.length; i++) {
        Car car = new Car {
            carIndex = i,
            name = aiCarNames[i],
            race = new CarRaceState {
                lap = 0
            },
            input = new CarInput,
            aiState = new CarAIState {
                wanderOffset = rnd(),
                baseAIParams = getBaseAIParams(i * 1.0 / aiCarNames.length)
            }
        };
        aiCarPool.add(car);
    }

    allCars = new Car[] { player };
    sortedCars = new Car[] { player };
    if (raceType != RACETYPE_PRACTICE) {

        // Add 7 AI cars to the race
        aiCars = new Car[0];
        for (int i = 0; i < 7; i++) {
            int poolIndex = rnd() * aiCarPool.length;
            Car car = aiCarPool[poolIndex];
            aiCarPool.remove(poolIndex);
            aiCars.add(car);
            // TODO: Rear view cars
            allCars.add(car);
            sortedCars.add(car);
            // TODO: Leaderboard
        }
    }

    // Layout cars in grid
    for (int i = 0; i < allCars.length; i++) {
        Car car = allCars[i];
        car.pos = new Vec {
            x = (i%2 - 0.5) * 3,
            z = i * 6
        };
    }

    sortCars(player.pos.z);
}

void sortCars(float z) {
    // Calculate relative Z position and screen segment index
    for (Car car : allCars) {
        float relZ = car.pos.z - z + 4;
        relZ -= floor(relZ / world.length) * world.length;
        relZ -= 4;
        car.relZ = relZ;
    }

    // Sort into descending order of relZ
    for (int i = 1; i < sortedCars.length; i++) {
        Car car = sortedCars[i];
        int j = i;
        while (j > 0 and sortedCars[j - 1].relZ < car.relZ) {
            sortedCars[j] = sortedCars[j - 1];
            j--;
        }
        sortedCars[j] = car;
    }
}

void updateAIInput(Car car) {
    CarInput input = car.input;
    CarAIState ai = car.aiState;
    CarAIParams param = car.aiState.aiParams;

    int zIndex = floor(car.pos.z);

    // Look a certain distance down the track and calculate where
    // the car is aiming.
    float xOffset = 0, turn = 0;
    float lookAheadDist = max(param.lookAhead * car.vel, 1);
    WorldSegment lookaheadSegment;
    for (int i = zIndex; i <= zIndex + floor(lookAheadDist); i++) {
        lookaheadSegment = world[i % world.length];
        xOffset += turn;
        turn += lookaheadSegment.turn;
    }

    // Calculate how to drive around other vehicles and whether
    // braking is required to avoid collision
    float limitLeft  = -(ROAD_WIDTH + CAR_WIDTH) / 2;
    float limitRight =  (ROAD_WIDTH + CAR_WIDTH) / 2;
    float targetVelocity = 10;
    float[] pts = new float[0];
    float aiXDelta = 0.15;              // How hard to steer. Increases if avoiding a potential collision.
    
    // Avoid other vehicles
    for (Car otherCar : allCars) {
        if (otherCar = car) continue;
        float deltaX = otherCar.pos.x - car.pos.x;
        float zDist = otherCar.pos.z - car.pos.z;               // Distance to back of other car
        zDist -= floor(zDist / world.length) * world.length;
        zDist -= CAR_LENGTH;
        float deltaVel = otherCar.vel - car.vel;
        float closeZDist = zDist - 3.85;                       // Distance to "close" following distance

        // Catching up to car?
        float timeUntilClose = 1000, timeUntilHit = 1000;
        if (deltaVel < 0) {
            // Time to catch up to other car
            timeUntilClose = closeZDist > 0 ? closeZDist / -(deltaVel - 0.01) : 0;
            timeUntilHit   = zDist > 0      ? zDist      / -(deltaVel - 0.01) : 0;
        }

        // Avoid all cars that will be "close" in 2 seconds
        if (timeUntilClose < 60) {

            // Add car position to points array
            pts.add(otherCar.pos.x);

            // Impending collision (in 2 seconds or less)?
            if (abs(deltaX) < CAR_WIDTH and timeUntilHit < 60) {

                // Reduce target velocity to other car's velocity, to ensure
                // car will brake if necessary.
                targetVelocity = min(targetVelocity, otherCar.vel);
            }
        }

        // If car is next to us, but we are in front, allow
        // room on whichever side they are on, to avoid a collision
        if (zDist <= 0 or zDist > world.length - CAR_LENGTH * 2) {
            // aiXDelta = 0.25;
            if (otherCar.pos.x < car.pos.x) {
                limitLeft += AI_CAR_WIDTH;
            }
            else {
                limitRight -= AI_CAR_WIDTH;
            }
        }
    }

    pts.add(limitLeft);
    pts.add(limitRight);

    // Sort points ascending
    for (int i = 1; i < pts.length; i++) {
        float v = pts[i];
        int j = i;
        while (j > 0 and pts[j - 1] > v) {
            pts[j] = pts[j - 1];
            j--;            
        }
        pts[j] = v;
    }

    // Get target AI X at lookahead segment
    // Use summed sine curves to implement horizontal "wandering",
    // so that every AI car doesn't aim for exactly the same line.
    ai.wanderOffset += 1.0 / param.wanderPeriod;
    float targetX = (lookaheadSegment.aiX + sin(ai.wanderOffset * MATH_PI * 2) + sin(ai.wanderOffset * MATH_PI * 2.6) * 0.4) * param.wander;

    // Look for nearest horizontal gap to aiX.
    // TODO: Rename variables for clarity
    float nearestXDist = 100, nearestX = targetX;
    for (int i = 1; i < pts.length; i++) {
        float pt = pts[i], prv = pts[i - 1];

        // Car must be able to fit between two other cars at
        // placed the horizontal points, allowing for the car widths.
        float gapLeft = prv + AI_CAR_WIDTH;
        float gapRight = pt - AI_CAR_WIDTH;
        float gapSize = gapRight - gapLeft;

        // Viable gap?
        if (gapSize > 0) {

            // Prefer to leave a horizontal gap when passing,
            // depending on available room.
            // Don't need to apply gap between edge of road however.
            float buffer = max(gapSize / 2, AI_PASS_BUFFER);
            if (prv > limitLeft)  gapLeft  += buffer;
            if (pt  < limitRight) gapRight -= buffer;

            // Clamp AI X to gap range to find closest X point
            float x = clamp(targetX, gapLeft, gapRight);
            float xDist = abs(x - car.pos.x);

            // Is this the nearest gap?
            if (xDist < nearestXDist) {
                nearestX = x;
                nearestXDist = xDist;
            }
        }
    }

    // Get target velocity
    // Start with max velocity for current track segment
    WorldSegment segment = world[zIndex % world.length];
    float trackMaxVelocity = segment.aiVelocity;

    // Apply AI parameters
    trackMaxVelocity *= param.velocityFactor;
    trackMaxVelocity = min(trackMaxVelocity, param.maxVelocity);

    // Apply to velocity
    targetVelocity = min(targetVelocity, trackMaxVelocity);

    // Accelerate/brake appropriately
    if (car.vel < targetVelocity - 0.004) {
        input.accel = 1;
    }
    else if (car.vel > targetVelocity) {
        input.accel = -1;
    }

    // Calculate steering to aim at "nearestx"
    float aiXOffset = nearestX - targetX;
    ai.aiXOffset += clamp(aiXOffset - ai.aiXOffset, -aiXDelta, aiXDelta);
    nearestX = clamp(targetX + ai.aiXOffset, limitLeft, limitRight);

    float targetTurn = clamp((nearestX + xOffset - car.pos.x) / lookAheadDist, -0.4, 0.4);
    float steering = (targetTurn - car.turn) / max(car.vel, 0.05) * 0.5;

    // Apply steering smoothing
    steering = lerp(input.steering, steering, param.steeringSmoothing);
    input.steering += clamp(steering - input.steering, -0.3, 0.3);
}

void updatePlayer() {

    // Update input
    updatePlayerInput();
    //updateAIInput(player);

    // Update car
    moveCar(player);

    // Animate wheels
    player.anim.wheelPrev = player.anim.wheelTurn;
    player.anim.wheelTurn += player.vel * VELOCITY_FACTOR * 18;

    updatePlayerRevs();

    updatePlayerSuspension();
}

void updateAICars() {
    for (Car car : aiCars) {
        CarAIState ai = car.aiState;
        if (ai.rndCounter <= 0) {
            ai.aiParams = getAIParams(ai.baseAIParams);
            ai.rndCounter = rnd() * 300 + 150;
        }
        else {
            ai.rndCounter--;
        }
        updateAIInput(car);
        moveCar(car);
        // car.vel = 0.2;
        // car.pos.z += car.vel * VELOCITY_FACTOR;
    }
}

void updatePlayerRevs() {
    bool isPreRace = false;     // TODO: Pre-race mode
    if (isPreRace) {
    }
    else {
        float r = 0.069;
        float gear = floor(player.vel / r);
        float revs = player.vel - gear * r;
        revs *= (0.7 - gear * 0.1)/r;
        revs += gear * 0.1 + 0.15;
        player.anim.revs = lerp(player.anim.revs, revs, 0.125);
    }
    setpitch(0, player.anim.revs * 35);
    setpitch(1, player.anim.revs * 35);
}

void updatePlayerSuspension() {
    float suspension = 0; //(player.vel - player.anim.prevVel) * 1500.0;
    suspension = clamp(suspension, -10, 10);
    player.anim.suspension = lerp(player.anim.suspension, suspension, 0.15);
    player.anim.prevVel = player.vel;

    // Move screen up/down based on suspension
    vanishY = SCREEN_HEIGHT / 2 + player.anim.suspension * PRATIO;
}

void collideSfx(int sfxIndex) {
    sfxIndex = min(sfxIndex, gameSfx.collision.length - 1);
    if (sfxIndex > collideSfxIndex) {
        playsfx(gameSfx.collision[sfxIndex], 3);
        collideSfxIndex = sfxIndex;
        collideSfxTimer = 15;
    }
}

void slideSfx(Sfx sfx) {
    if (currentSlideSfx != sfx) {
        currentSlideSfx = sfx;
        if (sfx != null) {
            playsfx(sfx, 2, true);
        }
        else {
            stopsfx(2);
        }
    }
}

void carBarrierCollision(Car car, float barrierX, float barrierXd) {

    // Prevent car from penetrating barrier
    car.pos = new Vec {
        x = barrierX,
        y = car.pos.y,
        z = car.pos.z
    };

    // Update XD and calculate collision intensity
    float deltaXd = barrierXd - car.xd;
    float intensity = abs(deltaXd);                        
    car.xd += deltaXd * 1.05;                               // 5% bounce

    // Apply collision friction
    float frictionFactor = max(0.25, 1 - intensity * 2);
    car.vel *= frictionFactor;

    // Turn car to align with barrier
    car.turn = lerp(car.turn, barrierXd, 0.1);

    if (car = player) {
        // Play collision sound effect, based on collision intensity
        if (intensity > 0.25)       collideSfx(3);
        else if (intensity > 0.1)   collideSfx(2);
        else                        collideSfx(1);        
    }
}

void moveCar(Car car) {
    bool isOnRoad = abs(car.pos.x) <= (ROAD_WIDTH - CAR_WIDTH) / 2;

    // Accelerate/brake
    if (car.input.accel < 0) {
        car.vel -= BRAKE_RATE;
    }
    else if (car.input.accel > 0) {
        car.vel += ACCEL_RATE;
    }
    else if (car.vel >= 0.0815) {
        car.vel += ACCEL_RATE * 0.2;    //?
    }

    // Rolling friction
    float frictionRoll = isOnRoad 
        ? FRICTION_ROLL_ROAD
        : FRICTION_ROLL_GROUND;

    frictionRoll *= car.vel;

    // Air friction
    float frictionAir = FRICTION_AIR;
    frictionAir *= pow(car.vel, 2);

    // Apply friction
    float friction = frictionRoll + frictionAir;
    car.vel -= friction;
    if (car.vel < 0) car.vel = 0;

    // Steer
    car.turn += car.input.steering * car.vel * 0.85;
    car.turn = clamp(car.turn, -1.5, 1.5);
    
    // Sideways friction
    float frictionGrip = isOnRoad ? FRICTION_SIDE : FRICTION_SIDE_GROUND;
    float frictionSlide = isOnRoad ? FRICTION_SIDE_SLIDE : FRICTION_SIDE_GROUND;
    float targetxd = car.turn * car.vel;
    float xddif = targetxd - car.xd;
    if (abs(xddif) < frictionGrip) {
        car.xd = targetxd;
        if (car = player) {
            slideSfx(null);         // Stop sliding sfx
        }
    }
    else {
        car.xd += sgn(xddif) * frictionSlide;
        if (car = player) {
            slideSfx(isOnRoad ? gameSfx.roadSlide : gameSfx.groundSlide);
        }
    }

    // Move car forwards
    float zIndex = floor(car.pos.z);
    car.pos += new Vec { 
        x = car.xd  * VELOCITY_FACTOR,
        z = car.vel * VELOCITY_FACTOR
    };

    // Account for moving onto new segments
    while (floor(car.pos.z) > zIndex) {

        // Get turn for current segment
        float turn = world[toint(zIndex) % world.length].turn;

        // Adjust car turn and xd
        car.turn -= turn;
        car.xd -= turn * car.vel;

        // Adjust horizon
        if (car = player) horizonX += turn * SCREEN_DIST;

        zIndex++;
    }

    // TODO: Laps, game rules

    // Barrier collisions
    WorldSegment seg = world[toint(zIndex) % world.length];
    WorldSegment nextSeg = world[toint(zIndex + 1) % world.length];
    float zOffset = car.pos.z - floor(car.pos.z);
    if (car.vel > 0) {
        float left  = lerp(seg.left, nextSeg.left, zOffset)   + CAR_WIDTH;
        float right = lerp(seg.right, nextSeg.right, zOffset) - CAR_WIDTH;
        float leftxd  = (nextSeg.left - seg.left)   * car.vel;
        float rightxd = (nextSeg.right - seg.right) * car.vel;
        if (car.pos.x > right and car.xd > rightxd) {
            carBarrierCollision(car, right, rightxd);
        }
        else if (car.pos.x < left and car.xd < leftxd) {
            carBarrierCollision(car, left, leftxd);
        }
    }

    // Calculate pitch
    car.pitch = lerp(seg.pitch, nextSeg.pitch, zOffset);
}

void doCarCollisions() {
    // Compare each car to each other car
    for (int i = 0; i < allCars.length - 1; i++) {
        
    }
}