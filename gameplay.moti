#include "gamedata"
#include "world"
#include "render"
#include "routines"
#include "gameconstants"

// Routines

void resetPlayer();
void initAICars();
void sortCars(float z);
void updatePlayer();
void updatePlayerRevs();
void updatePlayerSuspension();
void moveCar(Car car);

void initRace(Track track) {
    generateTrack(track);
    resetPlayer();
    initAICars();

    // Start looped engine soundeffects
    playsfx(gameSfx.engine1, 0, true);
    playsfx(gameSfx.engine2, 1, true, 0.4);
}

void updatePlayerInput() {
    CarInput input = player.input;

    // Acceleration
    input.accel = 0;
    if (keydn(KEY_UP)   or keydn("z") or btn(BTN_A)) input.accel += 1;
    if (keydn(KEY_DOWN) or keydn("x") or btn(BTN_B)) input.accel -= 1;
    input.accel += axis(AX_RTRIG);
    input.accel -= axis(AX_LTRIG);
    input.accel = clamp(input.accel, -1, 1);

    // Keyboard (or dpad) steering
    float sx = 0;
    if (keydn(KEY_LEFT)  or btn(BTN_LEFT))  sx -= 1;
    if (keydn(KEY_RIGHT) or btn(BTN_RIGHT)) sx += 1;
    if (sx != 0 and (input.keyboardSteering = 0 or sgn(sx) = sgn(input.keyboardSteering))) {
        // Turning wheel away from center
        sx *= 0.045;
        input.keyboardSteering += sx;
    }
    else {
        // Recentering
        float recenter = sx != 0 ? 0.08 : 0.02;
        if (abs(input.keyboardSteering) < recenter) {
            input.keyboardSteering = 0;
        }
        else {
            input.keyboardSteering -= sgn(input.keyboardSteering) * recenter;
        }
    }
    input.keyboardSteering = clamp(input.keyboardSteering, -1, 1);

    // Game controller analogue steering.
    // Apply deadzone, and smoothing.
    float axisx = axis(AX_X) * gameConfig.controllerFactor;
    if (abs(axisx) < gameConfig.controllerDeadzone) {
        axisx = 0;
    }
    else {
        axisx = sgn(axisx) * (abs(axisx) - gameConfig.controllerDeadzone) / (1 - gameConfig.controllerDeadzone);
    }
    input.controllerSteering = input.controllerSteering * gameConfig.controllerSmoothing + axisx * (1 - gameConfig.controllerSmoothing);
    input.controllerSteering = clamp(input.controllerSteering, -1, 1);
    if (abs(input.controllerSteering) < 0.01) input.controllerSteering = 0;

    // Steering
    input.steering = input.keyboardSteering + input.controllerSteering;
    input.steering = clamp(input.steering, -1, 1);
}

void updateGame() {
    sortCars(player.pos.z);
    updatePlayer();

    // Collision sfx timer
    if (collideSfxTimer > 0) {
        collideSfxTimer--;
    }
    else {
        collideSfxIndex = -1;
    }    
}

void resetPlayer() {
    player = new Car {
        name = "Player",
        pos = new Vec { 
            x = 1.5, 
            y = 0, 
            z = 0.0001 
        },
        anim = new CarAnimation {
            revs = 0.15
        },
        input = new CarInput,
        race = new CarRaceState
    };
}

CarAIParams getBaseAIParams(float f) {
    // TODO
    return new CarAIParams;
}

void initAICars() {

    // Build AI car pool
    aiCarPool = new Car[0];
    for (int i = 0; i < aiCarNames.length; i++) {
        Car car = new Car {
            carIndex = i,
            name = aiCarNames[i],
            race = new CarRaceState {
                lap = 0
            },
            input = new CarInput,
            aiState = new CarAIState {
                wanderOffset = rnd(),
                baseAIParams = getBaseAIParams(i * 1.0 / aiCarNames.length)
            }
        };
        aiCarPool.add(car);
    }

    allCars = new Car[] { player };
    sortedCars = new Car[] { player };
    if (raceType != RACETYPE_PRACTICE) {

        // Add 7 AI cars to the race
        aiCars = new Car[0];
        for (int i = 0; i < 7; i++) {
            int poolIndex = rnd() * aiCarPool.length;
            Car car = aiCarPool[poolIndex];
            aiCarPool.remove(poolIndex);
            aiCars.add(car);
            // TODO: Rear view cars
            allCars.add(car);
            sortedCars.add(car);
            // TODO: Leaderboard
        }
    }

    // Layout cars in grid
    for (int i = 0; i < allCars.length; i++) {
        Car car = allCars[i];
        car.pos = new Vec {
            x = (i%2 - 0.5) * 3,
            z = i * 6
        };
    }

    sortCars(player.pos.z);
}

void sortCars(float z) {
    // Calculate relative Z position and screen segment index
    for (Car car : allCars) {
        float relZ = car.pos.z - z + 4;
        relZ -= floor(relZ / world.length) * world.length;
        car.relZ = relZ;
    }

    // Sort into descending order of relZ
    for (int i = 1; i < sortedCars.length; i++) {
        Car car = sortedCars[i];
        int j = i;
        while (j > 0 and sortedCars[j - 1].relZ < car.relZ) {
            sortedCars[j] = sortedCars[j - 1];
            j--;
        }
        sortedCars[j] = car;
    }
}

void updatePlayer() {

    // Update input
    updatePlayerInput();

    // Update car
    moveCar(player);

    // Animate wheels
    player.anim.wheelPrev = player.anim.wheelTurn;
    player.anim.wheelTurn += player.vel * VELOCITY_FACTOR * 18;

    updatePlayerRevs();

    updatePlayerSuspension();
}

void updatePlayerRevs() {
    bool isPreRace = false;     // TODO: Pre-race mode
    if (isPreRace) {
    }
    else {
        float r = 0.069;
        float gear = floor(player.vel / r);
        float revs = player.vel - gear * r;
        revs *= (0.7 - gear * 0.1)/r;
        revs += gear * 0.1 + 0.15;
        player.anim.revs = lerp(player.anim.revs, revs, 0.125);
    }
    setpitch(0, player.anim.revs * 35);
    setpitch(1, player.anim.revs * 35);
}

void updatePlayerSuspension() {
    float suspension = (player.vel - player.anim.prevVel) * 1500.0;
    suspension = clamp(suspension, -10, 10);
    player.anim.suspension = lerp(player.anim.suspension, suspension, 0.15);
    player.anim.prevVel = player.vel;

    // Move screen up/down based on suspension
    vanishY = SCREEN_HEIGHT / 2 + player.anim.suspension * PRATIO;
}

void collideSfx(int sfxIndex) {
    sfxIndex = min(sfxIndex, gameSfx.collision.length - 1);
    if (sfxIndex > collideSfxIndex) {
        playsfx(gameSfx.collision[sfxIndex], 3);
        collideSfxIndex = sfxIndex;
        collideSfxTimer = 15;
    }
}

void slideSfx(Sfx sfx) {
    if (currentSlideSfx != sfx) {
        currentSlideSfx = sfx;
        if (sfx != null) {
            playsfx(sfx, 2, true);
        }
        else {
            stopsfx(2);
        }
    }
}

void carBarrierCollision(Car car, float barrierX, float barrierXd) {

    // Prevent car from penetrating barrier
    car.pos = new Vec {
        x = barrierX,
        y = car.pos.y,
        z = car.pos.z
    };

    // Update XD and calculate collision intensity
    float deltaXd = barrierXd - car.xd;
    float intensity = abs(deltaXd);                        
    car.xd += deltaXd * 1.05;                               // 5% bounce

    // Apply collision friction
    float frictionFactor = max(0.25, 1 - intensity * 2);
    car.vel *= frictionFactor;

    // Turn car to align with barrier
    car.turn = lerp(car.turn, barrierXd, 0.1);

    if (car = player) {
        // Play collision sound effect, based on collision intensity
        if (intensity > 0.25)       collideSfx(3);
        else if (intensity > 0.1)   collideSfx(2);
        else                        collideSfx(1);        
    }
}

void moveCar(Car car) {
    bool isOnRoad = abs(car.pos.x) <= (ROAD_WIDTH - CAR_WIDTH) / 2;

    // Accelerate/brake
    if (car.input.accel < 0) {
        car.vel -= BRAKE_RATE;
    }
    else if (car.input.accel > 0) {
        car.vel += ACCEL_RATE;
    }
    else if (car.vel >= 0.0815) {
        car.vel += ACCEL_RATE * 0.2;    //?
    }

    // Rolling friction
    float frictionRoll = isOnRoad 
        ? FRICTION_ROLL_ROAD
        : FRICTION_ROLL_GROUND;

    frictionRoll *= car.vel;

    // Air friction
    float frictionAir = FRICTION_AIR;
    frictionAir *= pow(car.vel, 2);

    // Apply friction
    float friction = frictionRoll + frictionAir;
    car.vel -= friction;
    if (car.vel < 0) car.vel = 0;

    // Steer
    car.turn += car.input.steering * car.vel * 0.85;
    car.turn = clamp(car.turn, -1.5, 1.5);
    
    // Sideways friction
    float frictionGrip = isOnRoad ? FRICTION_SIDE : FRICTION_SIDE_GROUND;
    float frictionSlide = isOnRoad ? FRICTION_SIDE_SLIDE : FRICTION_SIDE_GROUND;
    float targetxd = car.turn * car.vel;
    float xddif = targetxd - car.xd;
    if (abs(xddif) < frictionGrip) {
        car.xd = targetxd;
        if (car = player) {
            slideSfx(null);         // Stop sliding sfx
        }
    }
    else {
        car.xd += sgn(xddif) * frictionSlide;
        if (car = player) {
            slideSfx(isOnRoad ? gameSfx.roadSlide : gameSfx.groundSlide);
        }
    }

    // Move car forwards
    float zIndex = floor(car.pos.z);
    car.pos += new Vec { 
        x = car.xd  * VELOCITY_FACTOR,
        z = car.vel * VELOCITY_FACTOR
    };

    // Account for moving onto new segments
    while (floor(car.pos.z) > zIndex) {

        // Get turn for current segment
        float turn = world[toint(zIndex) % world.length].turn;

        // Adjust car turn and xd
        car.turn -= turn;
        car.xd -= turn * car.vel;

        // Adjust horizon
        if (car = player) horizonX += turn * SCREEN_DIST;

        zIndex++;
    }

    // TODO: Laps, game rules

    // Barrier collisions
    WorldSegment seg = world[toint(zIndex) % world.length];
    WorldSegment nextSeg = world[toint(zIndex + 1) % world.length];
    float zOffset = car.pos.z - floor(car.pos.z);
    if (car.vel > 0) {
        float left  = lerp(seg.left, nextSeg.left, zOffset)   + CAR_WIDTH;
        float right = lerp(seg.right, nextSeg.right, zOffset) - CAR_WIDTH;
        float leftxd  = (nextSeg.left - seg.left)   * car.vel;
        float rightxd = (nextSeg.right - seg.right) * car.vel;
        if (car.pos.x > right and car.xd > rightxd) {
            carBarrierCollision(car, right, rightxd);
        }
        else if (car.pos.x < left and car.xd < leftxd) {
            carBarrierCollision(car, left, leftxd);
        }
    }

    // Calculate pitch
    car.pitch = lerp(seg.pitch, nextSeg.pitch, zOffset);
}