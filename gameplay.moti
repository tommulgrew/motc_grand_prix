#include "gamedata"
#include "world"
#include "render"
#include "routines"
#include "gameconstants"
#include "ui"
#include "app"

// Routines

void resetPlayer();
void initCars();
void sortCars(float z);
void updateRace();
void updateRaceRules();
void updatePlayer();
void updateAICars();
void updatePlayerRevs();
void updatePlayerSuspension();
void moveCar(Car car);
void doCarCollisions();
void setRaceMode(int mode);
void setupRaceAfterQualifier();
void skipQualificationLap();
void startEngineSfx();

// External
void applyRaceResults(Car[] raceResults);

void initRace() {
    float saveSeed = rnd();
    srnd(race.track.randomSeed);
    generateTrack(race.track);
    srnd(saveSeed * 1000000000000);
    resetPlayer();
    initCars();

    // Start looped engine soundeffects
    startEngineSfx();

    if (race.isPracticeMode) {
        setRaceMode(RACEMODE_RACING);
    }
    else {
        setRaceMode(RACEMODE_PRERACE);
    }
}

void updatePlayerInput() {
    CarInput input = player.input;

    // Acceleration
    input.accel = 0;
    if (keydn(KEY_UP)   or keydn("z") or btn(BTN_B)) input.accel += 1;
    if (keydn(KEY_DOWN) or keydn("x") or btn(BTN_A)) input.accel -= 1;
    input.accel += axis(AX_RTRIG);
    input.accel -= axis(AX_LTRIG);
    input.accel = clamp(input.accel, -1, 1);

    // Keyboard (or dpad) steering
    float sx = 0;
    if (keydn(KEY_LEFT)  or btn(BTN_LEFT))  sx -= 1;
    if (keydn(KEY_RIGHT) or btn(BTN_RIGHT)) sx += 1;
    if (sx != 0 and (input.keyboardSteering = 0 or sgn(sx) = sgn(input.keyboardSteering))) {
        // Turning wheel away from center
        sx *= 0.045;
        input.keyboardSteering += sx;
    }
    else {
        // Recentering
        float recenter = sx != 0 ? 0.08 : 0.02;
        if (abs(input.keyboardSteering) < recenter) {
            input.keyboardSteering = 0;
        }
        else {
            input.keyboardSteering -= sgn(input.keyboardSteering) * recenter;
        }
    }
    input.keyboardSteering = clamp(input.keyboardSteering, -1, 1);

    // Game controller analogue steering.
    // Apply deadzone, response curve, and smoothing.
    float axisx = axis(AX_X) * gameConfig.controllerFactor;
    if (abs(axisx) < gameConfig.controllerDeadzone) {
        axisx = 0;
    }
    else {
        axisx = sgn(axisx) * (abs(axisx) - gameConfig.controllerDeadzone) / (1 - gameConfig.controllerDeadzone);
    }
    axisx = sgn(axisx) * pow(abs(axisx), gameConfig.controllerCurve);
    input.controllerSteering = input.controllerSteering * gameConfig.controllerSmoothing + axisx * (1 - gameConfig.controllerSmoothing);
    input.controllerSteering = clamp(input.controllerSteering, -1, 1);
    if (abs(input.controllerSteering) < 0.01) input.controllerSteering = 0;

    // Steering
    input.steering = input.keyboardSteering + input.controllerSteering;
    input.steering = clamp(input.steering, -1, 1);
}

void updateGame(UIInput uiInput) {
    raceSequenceTimer++;

    if (raceMode = RACEMODE_PRERACE) {
        // Player can rev engine in pre race mode.
        updatePlayerInput();
        updatePlayerRevs();   

        // Start race after 3..2..1 sequence
        if (raceSequenceTimer >= 120) {
            setRaceMode(RACEMODE_RACING);
            playsfx(gameSfx.go);
        }
        else if (raceSequenceTimer >= 30 and raceSequenceTimer % 30 = 0) {
            playsfx(gameSfx.getReady);
        }
    }
    else if (raceMode = RACEMODE_RACING) {
        updateRace();
        updateRaceRules();
        if (player.race.isFinished) {
            setRaceMode(RACEMODE_POSTRACE);
        }
    }
    else if (raceMode = RACEMODE_POSTRACE) {
        updateRace();
        updateRaceRules();          // So cars that haven't finished yet can finish

        // Ignore input for 3 seconds. 
        // After that, pressing button proceeds to race results.
        // Or if in demo mode, it will automatically quit to menu
        if (raceSequenceTimer > 90) {
            if (race.isDemo) {
                setGameMode(GAMEMODE_MENU);
            }
            else if (uiInput.btnPressed[UI_SELECT]) {
                setRaceMode(RACEMODE_RESULTS);
                fadeTransition();
            }
        }
    }
    else if (raceMode = RACEMODE_RESULTS) {
        updateRace();

        // Ignore input for 3 seconds. 
        // After that, pressing button returns to menu
        if (raceSequenceTimer > 90 and uiInput.btnPressed[UI_SELECT]) {
            if (race.isQualificationLap) {
                setupRaceAfterQualifier();
                fadeTransition();
            }
            else {
                if (not race.isDemo) {
                    applyRaceResults(raceResults);
                }
                setGameMode(GAMEMODE_MENU);
            }
        }
    }

    // Pressing a button quits demo mode
    if (race.isDemo and uiInput.btnPressed[UI_SELECT]) {
        setGameMode(GAMEMODE_MENU);
    }
}

void updateRace() {
    if (raceMode != RACEMODE_RESULTS) {
        updatePlayer();
    }
    updateAICars();

    if (!race.isQualificationLap) {         // Cars cannot collide with each other during qualification lap
        doCarCollisions();
    }

    // Collision sfx timer
    if (collideSfxTimer > 0) {
        collideSfxTimer--;
    }
    else {
        collideSfxIndex = -1;
    }
}

void updateRaceRules() {
    for (Car car : allCars) {
        if (not car.race.isFinished) {
            car.race.raceTime++;

            // Cars start behind the finish line. 
            // Lap timer starts once cars pass the line
            if (car.pos.z > world.length + race.track.finishLineDistance) {
                car.race.currentLapTime++;
            }

            // Lap complete?
            int lap = getLap(car.pos.z);
            if (lap > car.race.lap) {
                car.race.lap = lap;

                // Update lap times
                car.race.lastLapTime = car.race.currentLapTime;
                if (car.race.bestLapTime = 0 or car.race.currentLapTime < car.race.bestLapTime) {
                    car.race.bestLapTime = car.race.currentLapTime;
                }
                car.race.currentLapTime = 0;

                // Play sound effect for player
                if (car = player) playsfx(gameSfx.lapBell);

                // Race complete?
                int totalLaps = race.isQualificationLap ? 1 : race.laps;
                if (not race.isPracticeMode and lap > totalLaps) {
                    car.race.isFinished = true;
                    raceResults.add(car);
                }
            }
        }
    }
}

CarAIParams getBaseAIParams(float f) {
    DifficultyLevel difficulty = race.difficulty;
    f = clamp(f + difficulty.baseFactorOffset, 0.1, 1);
    return new CarAIParams {
        velocityFactor = lerp(difficulty.velocityFactorRange.min, difficulty.velocityFactorRange.max, f),
        maxVelocity = lerp(difficulty.maxVelocityRange.min / 600, difficulty.maxVelocityRange.max / 600, f),
        steeringSmoothing = difficulty.steeringSmoothing,
        wander = difficulty.wander,
        wanderPeriod = 400,
        lookAhead = difficulty.lookAhead
    };
}

CarAIParams getAIParams(CarAIParams base) {
    DifficultyLevel difficulty = race.difficulty;
    return new CarAIParams {
        velocityFactor = base.velocityFactor + rnd2(difficulty.velocityFactorVariance),
        maxVelocity = base.maxVelocity + rnd2(difficulty.maxVelocityVariance / 600),
        steeringSmoothing = min(base.steeringSmoothing + rnd2(difficulty.steeringSmoothingVariance), 0.2),
        wander = base.wander + rnd2(difficulty.wanderVariance),
        wanderPeriod = base.wanderPeriod + rnd2(100),
        lookAhead = base.lookAhead + rnd2(difficulty.lookAheadVariance)
    };
}

void resetPlayer() {
    player = new Car {
        name = "Player",
        pos = new Vec { 
            x = 1.5, 
            y = 0, 
            z = 0.0001 
        },
        anim = new CarAnimation {
            revs = 0.15
        },
        aiState = new CarAIState {
            wanderOffset = rnd(),
            baseAIParams = getBaseAIParams(0.75)
        },
        input = new CarInput,
        race = new CarRaceState { lap = 1 }
    };
    player.aiState.aiParams = player.aiState.baseAIParams;
}

void layoutCars(Car[] cars) {
    // Layout cars in grid
    for (int i = 0; i < cars.length; i++) {
        Car car = cars[i];
        int carPositionIndex = race.isQualificationLap ? 0 : i;
        car.pos = new Vec {
            x = (carPositionIndex%2 - 0.5) * 3,
            z = race.track.finishLineDistance + world.length - carPositionIndex * 6 - 9.9999
        };
    }
}

void initCars() {

    // Create car arrays
    allCars = new Car[0];
    sortedCars = new Car[] { player };
    leaderboard = new Car[] { player };
    raceResults = new Car[0];
    rearViewCars = new Car[0];
    aiCars = new Car[0];

    // Add AI cars
    for (int aiCarIndex : race.aiCarRoster) {
        Car car = new Car {
            carIndex = aiCarIndex,
            name = aiCarNames[aiCarIndex],
            race = new CarRaceState { lap = 1 },
            input = new CarInput,
            aiState = new CarAIState {
                wanderOffset = rnd(),
                baseAIParams = getBaseAIParams(aiCarIndex * 1.0 / aiCarNames.length)
            }
        };
        aiCars.add(car);    
        rearViewCars.add(car);
        allCars.add(car);
        sortedCars.add(car);
        rearViewCars.add(car);
        leaderboard.add(car);
    }

    // Add player car (so they start from last in demo mode)
    allCars.add(player);

    layoutCars(allCars);
}

void setupRaceAfterQualifier() {

    // Must clear qualification lap flag before laying out cars    
    race.isQualificationLap = false;

    // Reset cars
    for (Car car : allCars) {
        car.vel = 0;
        car.xd = 0;
        car.input = new CarInput;
        car.race = new CarRaceState { lap = 1 };        
    }
    player.anim = new CarAnimation;

    // Layout cars in grid, in race result order
    layoutCars(raceResults);
    
    // Clear race results
    raceResults = new Car[0];

    // Switch to race mode
    setRaceMode(RACEMODE_PRERACE);
    startEngineSfx();
}

void skipQualificationLap() {

    // Add AI cars to current race results
    for (Car car : leaderboard) {
        if (car != player && not car.race.isFinished) {
            car.race.isFinished = true;
            raceResults.add(car);
        }
    }

    // Add player in last place
    raceResults.add(player);

    // Setup for race
    setupRaceAfterQualifier();
}

void sortCars(float z) {

    // Calculate relative Z position and screen segment index.
    // Calculate rear view Z as well
    for (Car car : aiCars) {
        float relZ = car.pos.z - z + 4;
        relZ -= floor(relZ / world.length) * world.length;
        relZ -= 4;
        car.relZ = relZ;

        float rearViewZ = z - car.pos.z;
        rearViewZ -= floor(rearViewZ / world.length) * world.length;
        car.rearViewZ = rearViewZ;
    }

    // Sort into descending order of relZ
    for (int i = 1; i < sortedCars.length; i++) {
        Car car = sortedCars[i];
        int j = i;
        while (j > 0 and sortedCars[j - 1].relZ < car.relZ) {
            sortedCars[j] = sortedCars[j - 1];
            j--;
        }
        sortedCars[j] = car;
    }

    // Sort rear view cars
    for (int i = 1; i < rearViewCars.length; i++) {
        Car car = rearViewCars[i];
        int j = i;
        while (j > 0 and rearViewCars[j - 1].rearViewZ < car.rearViewZ) {
            rearViewCars[j] = rearViewCars[j - 1];
            j--;
        }
        rearViewCars[j] = car;
    }

    // Sort leaderboard into descending order of Z
    for (int i = 1; i < leaderboard.length; i++) {
        Car car = leaderboard[i];
        int j = i;
        while (j > 0 and leaderboard[j - 1].pos.z < car.pos.z) {
            leaderboard[j] = leaderboard[j - 1];
            j--;            
        }
        leaderboard[j] = car;
    }
}

void updateAIInput(Car car) {
    CarInput input = car.input;
    CarAIState ai = car.aiState;
    CarAIParams param = car.aiState.aiParams;

    int zIndex = getSegmentIndex(car.pos.z);

    // Look a certain distance down the track and calculate where
    // the car is aiming.
    float xOffset = 0, turn = 0;
    float lookAheadDist = max(param.lookAhead * car.vel, 1);
    WorldSegment lookaheadSegment;
    for (int i = zIndex; i <= zIndex + floor(lookAheadDist); i++) {
        lookaheadSegment = getSegment(i);
        xOffset += turn;
        turn += lookaheadSegment.turn;
    }

    // Calculate how to drive around other vehicles and whether
    // braking is required to avoid collision
    float limitLeft  = -(ROAD_WIDTH + CAR_WIDTH) / 2;
    float limitRight =  (ROAD_WIDTH + CAR_WIDTH) / 2;
    float targetVelocity = 10;
    float[] pts = new float[0];
    float aiXDelta = 0.15;              // How hard to steer. Increases if avoiding a potential collision.
    
    // Avoid other vehicles
    if (not race.isQualificationLap) {
        for (Car otherCar : allCars) {
            if (otherCar = car) continue;
            float deltaX = otherCar.pos.x - car.pos.x;
            float zDist = otherCar.pos.z - car.pos.z;               // Distance to back of other car
            zDist -= floor(zDist / world.length) * world.length;
            zDist -= CAR_LENGTH;
            float deltaVel = otherCar.vel - car.vel;
            float closeZDist = zDist - 3.85;                       // Distance to "close" following distance

            // Catching up to car?
            float timeUntilClose = 1000, timeUntilHit = 1000;
            if (deltaVel < 0) {
                // Time to catch up to other car
                timeUntilClose = closeZDist > 0 ? closeZDist / -(deltaVel - 0.01) : 0;
                timeUntilHit   = zDist > 0      ? zDist      / -(deltaVel - 0.01) : 0;
            }

            // Avoid all cars that will be "close" in 2 seconds
            if (timeUntilClose < 60) {

                // Add car position to points array
                pts.add(otherCar.pos.x);

                // Impending collision (in 2 seconds or less)?
                if (abs(deltaX) < CAR_WIDTH and timeUntilHit < 60) {

                    // Reduce target velocity to other car's velocity, to ensure
                    // car will brake if necessary.
                    targetVelocity = min(targetVelocity, otherCar.vel);
                }
            }

            // If car is next to us, but we are in front, allow
            // room on whichever side they are on, to avoid a collision
            if (zDist <= 0 or zDist > world.length - CAR_LENGTH * 2) {
                // aiXDelta = 0.25;
                if (otherCar.pos.x < car.pos.x) {
                    limitLeft += AI_CAR_WIDTH;
                }
                else {
                    limitRight -= AI_CAR_WIDTH;
                }
            }
        }
    }

    pts.add(limitLeft);
    pts.add(limitRight);

    // Sort points ascending
    for (int i = 1; i < pts.length; i++) {
        float v = pts[i];
        int j = i;
        while (j > 0 and pts[j - 1] > v) {
            pts[j] = pts[j - 1];
            j--;            
        }
        pts[j] = v;
    }

    // Get target AI X at lookahead segment
    // Use summed sine curves to implement horizontal "wandering",
    // so that every AI car doesn't aim for exactly the same line.
    ai.wanderOffset += 1.0 / param.wanderPeriod;
    float targetX = (lookaheadSegment.aiX + sin(ai.wanderOffset * MATH_PI * 2) + sin(ai.wanderOffset * MATH_PI * 2.6) * 0.4) * param.wander;

    // Look for nearest horizontal gap to aiX.
    // TODO: Rename variables for clarity
    float nearestXDist = 100, nearestX = targetX;
    for (int i = 1; i < pts.length; i++) {
        float pt = pts[i], prv = pts[i - 1];

        // Car must be able to fit between two other cars at
        // placed the horizontal points, allowing for the car widths.
        float gapLeft = prv + AI_CAR_WIDTH;
        float gapRight = pt - AI_CAR_WIDTH;
        float gapSize = gapRight - gapLeft;

        // Viable gap?
        if (gapSize > 0) {

            // Prefer to leave a horizontal gap when passing,
            // depending on available room.
            // Don't need to apply gap between edge of road however.
            float buffer = max(gapSize / 2, AI_PASS_BUFFER);
            if (prv > limitLeft)  gapLeft  += buffer;
            if (pt  < limitRight) gapRight -= buffer;

            // Clamp AI X to gap range to find closest X point
            float x = clamp(targetX, gapLeft, gapRight);
            float xDist = abs(x - car.pos.x);

            // Is this the nearest gap?
            if (xDist < nearestXDist) {
                nearestX = x;
                nearestXDist = xDist;
            }
        }
    }

    // Get target velocity
    // Start with max velocity for current track segment
    WorldSegment segment = getSegment(zIndex);
    float trackMaxVelocity = segment.aiVelocity;

    // Apply AI parameters
    trackMaxVelocity *= param.velocityFactor;
    trackMaxVelocity = min(trackMaxVelocity, param.maxVelocity);

    // Apply to velocity
    targetVelocity = min(targetVelocity, trackMaxVelocity);

    // Accelerate/brake appropriately
    if (car.vel < targetVelocity - 0.004) {
        input.accel = 1;
    }
    else if (car.vel > targetVelocity) {
        input.accel = -1;
    }

    // Calculate steering to aim at "nearestx"
    float aiXOffset = nearestX - targetX;
    ai.aiXOffset += clamp(aiXOffset - ai.aiXOffset, -aiXDelta, aiXDelta);
    nearestX = clamp(targetX + ai.aiXOffset, limitLeft, limitRight);

    float targetTurn = clamp((nearestX + xOffset - car.pos.x) / lookAheadDist, -0.4, 0.4);
    float steering = (targetTurn - car.turn) / max(car.vel, 0.05) * 0.5;

    // Apply steering smoothing
    steering = lerp(input.steering, steering, param.steeringSmoothing);
    input.steering += clamp(steering - input.steering, -0.3, 0.3);
}

void updatePlayer() {

    // Update input
    if (raceMode = RACEMODE_POSTRACE) {
        // AI controls car during post-race sequence
        updateAIInput(player);
    }
    else if (raceMode = RACEMODE_RACING) {
        // Player controls car during race.
        if (race.isDemo) {
            updateAIInput(player);        
        }
        else {
            updatePlayerInput();
        }
    }

    // Update car
    moveCar(player);
    updatePlayerSuspension();
    updatePlayerRevs();

    // Animate wheels
    player.anim.wheelPrev = player.anim.wheelTurn;
    player.anim.wheelTurn += player.vel * VELOCITY_FACTOR * 18;
}

void updateAICars() {
    for (Car car : aiCars) {
        CarAIState ai = car.aiState;
        if (ai.rndCounter <= 0) {
            ai.aiParams = getAIParams(ai.baseAIParams);
            ai.rndCounter = rnd() * 300 + 150;
        }
        else {
            ai.rndCounter--;
        }
        updateAIInput(car);
        moveCar(car);
    }
}

void updateEnginePitch() {
    setpitch(0, player.anim.revs * 35);
    setpitch(1, player.anim.revs * 35);
}

void updatePlayerRevs() {
    if (raceMode = RACEMODE_PRERACE and not race.isDemo) {
        // Button revs engine
        float revTarget = lerp(0.1, 0.85, max(player.input.accel, 0));
        player.anim.revs = lerp(player.anim.revs, revTarget, 0.075);
        updateEnginePitch();
    }
    else if (raceMode = RACEMODE_RACING or raceMode = RACEMODE_POSTRACE) {
        // Base revs on speed, with some simulated gear ratios.
        float r = 0.069;
        float gear = floor(player.vel / r);
        float revs = player.vel - gear * r;
        revs *= (0.7 - gear * 0.1)/r;
        revs += gear * 0.1 + 0.15;
        player.anim.revs = lerp(player.anim.revs, revs, 0.125);
        updateEnginePitch();
    }
}

void updatePlayerSuspension() {
    float suspension = (player.vel - player.anim.prevVel) * 1500.0;
    suspension = clamp(suspension, -10, 10);
    player.anim.suspension = lerp(player.anim.suspension, suspension, 0.15);
    player.anim.prevVel = player.vel;

    // Move screen up/down based on suspension
    vanishY = SCREEN_HEIGHT / 2 + player.anim.suspension * PRATIO;
}

void collideSfx(int sfxIndex) {
    sfxIndex = min(sfxIndex, gameSfx.collision.length - 1);
    if (sfxIndex > collideSfxIndex) {
        playsfx(gameSfx.collision[sfxIndex], 3);
        collideSfxIndex = sfxIndex;
        collideSfxTimer = 15;
    }
}

void slideSfx(Sfx sfx) {
    if (currentSlideSfx != sfx) {
        currentSlideSfx = sfx;
        if (sfx != null) {
            playsfx(sfx, 2, true);
        }
        else {
            stopsfx(2);
        }
    }
}

void carBarrierCollision(Car car, float barrierX, float barrierXd) {

    // Prevent car from penetrating barrier
    car.pos = new Vec {
        x = barrierX,
        y = car.pos.y,
        z = car.pos.z
    };

    // Update XD and calculate collision intensity
    float deltaXd = barrierXd - car.xd;
    float intensity = abs(deltaXd);                        
    car.xd += deltaXd * 1.05;                               // 5% bounce

    // Apply collision friction
    float frictionFactor = max(0.25, 1 - intensity * 2);
    car.vel *= frictionFactor;

    // Turn car to align with barrier
    car.turn = lerp(car.turn, barrierXd, 0.1);

    if (car = player) {
        // Play collision sound effect, based on collision intensity
        if (intensity > 0.25)       collideSfx(3);
        else if (intensity > 0.1)   collideSfx(2);
        else                        collideSfx(1);        
    }
}

void moveCar(Car car) {
    bool isOnRoad = abs(car.pos.x) <= (ROAD_WIDTH - CAR_WIDTH) / 2;

    // Accelerate/brake
    if (car.input.accel < 0) {
        car.vel -= BRAKE_RATE;
    }
    else if (car.input.accel > 0) {
        car.vel += ACCEL_RATE;
    }
    else if (car.vel >= 0.0815) {
        car.vel += ACCEL_RATE * 0.2;    //?
    }

    // Rolling friction
    float frictionRoll = isOnRoad 
        ? FRICTION_ROLL_ROAD
        : FRICTION_ROLL_GROUND;

    frictionRoll *= car.vel;

    // Air friction
    float frictionAir = FRICTION_AIR;
    frictionAir *= pow(car.vel, 2);

    // Apply friction
    float friction = frictionRoll + frictionAir;
    car.vel -= friction;
    if (car.vel < 0) car.vel = 0;

    // Steer
    car.turn += car.input.steering * car.vel * 0.85;
    car.turn = clamp(car.turn, -1.5, 1.5);
    
    // Sideways friction
    float frictionGrip = isOnRoad ? FRICTION_SIDE : FRICTION_SIDE_GROUND;
    float frictionSlide = isOnRoad ? FRICTION_SIDE_SLIDE : FRICTION_SIDE_GROUND;
    float targetxd = car.turn * car.vel;
    float xddif = targetxd - car.xd;
    if (abs(xddif) < frictionGrip) {
        car.xd = targetxd;
        if (car = player) {
            slideSfx(null);         // Stop sliding sfx
        }
    }
    else {
        car.xd += sgn(xddif) * frictionSlide;
        if (car = player) {
            slideSfx(isOnRoad ? gameSfx.roadSlide : gameSfx.groundSlide);
        }
    }

    // Move car forwards
    int zIndex = floor(car.pos.z);
    car.pos += new Vec { 
        x = car.xd  * VELOCITY_FACTOR,
        z = car.vel * VELOCITY_FACTOR
    };

    // Account for moving onto new segments
    while (car.pos.z >= zIndex + 1) {

        // Get turn for current segment
        float turn = getSegment(zIndex).turn;

        // Adjust car turn and xd
        car.turn -= turn;
        car.xd -= turn * car.vel;

        // Adjust horizon
        if (car = player) horizonX += turn * SCREEN_DIST;

        zIndex++;
    }

    // Barrier collisions
    WorldSegment seg = getSegment(zIndex);
    WorldSegment nextSeg = getSegment(zIndex + 1);
    float zOffset = frac(car.pos.z);
    if (car.vel > 0) {
        float left  = lerp(seg.left, nextSeg.left, zOffset)   + CAR_WIDTH;
        float right = lerp(seg.right, nextSeg.right, zOffset) - CAR_WIDTH;
        float leftxd  = (nextSeg.left - seg.left)   * car.vel;
        float rightxd = (nextSeg.right - seg.right) * car.vel;
        if (car.pos.x > right and car.xd > rightxd) {
            carBarrierCollision(car, right, rightxd);
        }
        else if (car.pos.x < left and car.xd < leftxd) {
            carBarrierCollision(car, left, leftxd);
        }
    }

    // Calculate pitch
    // Store relative to current segment
    car.pitch = (nextSeg.pitch - seg.pitch) * zOffset;
}

void doCarCollisions() {
    // Compare each car to each other car
    for (int i = 0; i < allCars.length - 1; i++) {
        Car a = allCars[i];
        for (int j = i + 1; j < allCars.length; j++) {
            Car b = allCars[j];

            // Relative car positions
            float xd = b.pos.x - a.pos.x;
            float zd = b.pos.z - a.pos.z;
            zd -= floor(zd / world.length) * world.length;
            if (zd > world.length / 2) zd -= world.length;

            // Get positions in multiple of car dimensions
            float axd = abs(xd) / CAR_WIDTH;
            float azd = abs(zd) / CAR_LENGTH;

            // Collision?
            if (axd > 1 or azd > 1) continue;
            
            // Relative velocity X and Z
            float xv = b.xd - a.xd;
            float zv = b.vel - a.vel;

            if (axd > azd) {
                // Potential X collision
                if ((xd > 0) != (xv > 0)) {     // Converging?

                    // Update velocity
                    float impulse = xv * COLLISION_ELASTIC;
                    a.xd += impulse;
                    b.xd -= impulse;

                    // Update position
                    float ox = sgn(xd) * CAR_WIDTH - xd;
                    Vec posAdj = new Vec { x = ox / 2 };
                    a.pos -= posAdj;
                    b.pos += posAdj;

                    // Collision sound effect
                    if (a = player or b = player) collideSfx(abs(impulse) * 4);
                }
            }
            else {
                // Potential Z collision
                if ((zd > 0) != (zv > 0)) {     // Converging?

                    // Update velocity
                    float impulse = zv * COLLISION_ELASTIC;
                    a.vel += impulse;
                    b.vel -= impulse;

                    // Update position
                    float oz = sgn(zd) * CAR_LENGTH - zd;
                    Vec posAdj = new Vec { z = oz / 2 };
                    a.pos -= posAdj;
                    b.pos += posAdj;

                    // Collision sound effect
                    if (a = player or b = player) collideSfx(abs(impulse) * 4);
                }
            }
        }
    }
}

void removeCar(Car[] cars, Car car) {
    for (int i = 0; i < cars.length; i++) {
        if (cars[i] = car) {
            cars.remove(i);
            break;
        }
    }
}

void setRaceMode(int mode) {
    raceMode = mode;
    raceSequenceTimer = 0;
    
    if (raceMode = RACEMODE_RESULTS) {

        // Add any non-finished cars to the podium, in their current leaderboard order
        for (Car car : leaderboard) {
            if (!car.race.isFinished) {
                car.race.isFinished = true;
                raceResults.add(car);
            }
        }

        // Setup for finish line camera
        stopsfx(); 

        if (not race.isQualificationLap) {  
            removeCar(allCars, player);
            removeCar(sortedCars, player);
        }
    }
}

void startEngineSfx() {
    playsfx(gameSfx.engine1, 0, true);
    playsfx(gameSfx.engine2, 1, true, 0.4);
}