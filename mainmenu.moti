#include "menu"
#include "render"
#include "app"
#include "ui"
#include "tournament"

// Constants

// Main menu item enums

const int MAIN_MENU_TRACK = 1;
const int MAIN_MENU_LAPS = 2;
const int MAIN_MENU_DIFFICULTY = 3;
const int MAIN_MENU_STARTRACE = 4;
const int MAIN_MENU_QUIT = 5;
const int MAIN_MENU_RACETYPE = 6;

string[] raceTypeNames = new string[] {
    "Single Race",
    "Tournament",
    "Practice"
};

// Structures

struct MainMenuState {
    MenuState state;
    int carPaletteIndex;
    int idleTimer;
}

// Data

MenuParams mainMenuParams = new MenuParams {
    y = SCREEN_HEIGHT * 0.75,
    itemSpacing = 16,
    barHeight = 16,
    drawBackground = false
};
MainMenuState mainMenu;

// Routines

MenuItem[] getMainMenuItems();
int[] makeAICarRoster(int count);
void startRace(RaceParams raceParams);
void doDemo();

void initMainMenu() {
    mainMenu = new MainMenuState {
        state = new MenuState,
        carPaletteIndex = rnd() * aiCarPalettes.length
    };
}

void drawMainMenu() {
    cls(1);

    // Title text
    const int TITLE_BASE_SCALE = 2;
    const int TITLE_X = SCREEN_WIDTH / 2 - 8 * 6 * TITLE_BASE_SCALE * PRATIO;
    const int TITLE_Y = SCREEN_HEIGHT * 0.15;
    const int TITLE_SCALE = TITLE_BASE_SCALE * PRATIO;
    color(5);
    printScaled("Mot's Grand Prix", TITLE_X, TITLE_Y + 2 * PRATIO, TITLE_SCALE);
    color(6);
    printScaled("Mot's Grand Prix", TITLE_X, TITLE_Y, TITLE_SCALE);

    // Draw a racing car
    colmap(aiCarPalettes[mainMenu.carPaletteIndex]);
    drawCar(new Transform {
        translate = new Vec { z = 2.5, y = -0.1 },
        skewX = -0.5,
        skewY = -0.3
    });
    colmap();

    // Menu UI
    MenuItem[] items = getMainMenuItems();
    drawMenu(mainMenuParams, mainMenu.state, items);
}

void updateMainMenu(UIInput input) {

    // Items
    MenuItem[] items = getMainMenuItems();

    // Update menu
    MenuAction action = updateMenu(mainMenu.state, items, input);

    // Perform menu action
    if (action != null) {
        if (action.menuAction = MENU_ACTION_SELECT) {
            if (action.itemID = MAIN_MENU_STARTRACE) {
                RaceParams raceParams = new RaceParams {
                    track = tracks[gameConfig.trackIndex],
                    laps = lapOptions[gameConfig.lapOptionIndex],
                    difficulty = difficultyLevels[gameConfig.difficulty],
                    aiCarRoster = new int[0],
                    isPracticeMode = gameConfig.raceType = RACETYPE_PRACTICE,
                    playerColour = gameConfig.playerColour
                };
                if (gameConfig.raceType = RACETYPE_SINGLE) {
                    raceParams.aiCarRoster = makeAICarRoster(AI_CAR_COUNT);
                }
                startRace(raceParams);
            }
            else if (action.itemID = MAIN_MENU_QUIT) {
                saveConfig();
                quitApp = true;
            }
        }
        else if (action.menuAction = MENU_ACTION_CHANGE) {
            if (action.itemID = MAIN_MENU_RACETYPE) {
                gameConfig.raceType = clamp(gameConfig.raceType + action.delta, 0, 2);
            }
            if (action.itemID = MAIN_MENU_TRACK) {
                gameConfig.trackIndex = clamp(gameConfig.trackIndex + action.delta, 0, tracks.length - 1);
            }
            else if (action.itemID = MAIN_MENU_LAPS) {
                gameConfig.lapOptionIndex = clamp(gameConfig.lapOptionIndex + action.delta, 0, lapOptions.length - 1);
            }
            else if (action.itemID = MAIN_MENU_DIFFICULTY) {
                gameConfig.difficulty = clamp(gameConfig.difficulty + action.delta, 0, difficultyLevels.length - 1);
            }
        }
    }

    // Run demo after X seconds of idle time
    mainMenu.idleTimer++;
    for (bool btnDown : input.btnDown) {
        if (btnDown) {
            mainMenu.idleTimer = 0;
            break;
        }
    }
    if (mainMenu.idleTimer > 30 * 30) {
        doDemo();
    }
}

MenuItem[] getMainMenuItems() {
    MenuItem[] items = new MenuItem[] {
        new MenuItem { id = MAIN_MENU_RACETYPE, text = raceTypeNames[gameConfig.raceType] }
    };
    if (gameConfig.raceType != RACETYPE_TOURNAMENT) {
        items.add(new MenuItem { id = MAIN_MENU_TRACK, text = "Track: " + tracks[gameConfig.trackIndex].name });
    }
    if (gameConfig.raceType != RACETYPE_PRACTICE) {
        items.add(new MenuItem { id = MAIN_MENU_LAPS, text = "Laps: " + lapOptions[gameConfig.lapOptionIndex] });
        items.add(new MenuItem { id = MAIN_MENU_DIFFICULTY, text = "Difficulty: " + difficultyLevels[gameConfig.difficulty].name });
    }
    items.add(new MenuItem { id = MAIN_MENU_STARTRACE, text = "!! Race !!" });

    // Exclude quit option from web version, as quitting doesn't make sense.
    // (The game just ends and the application becomes unresponsive.)
    if (hostplatform() != "web") {
        items.add(new MenuItem { id = MAIN_MENU_QUIT, text = "Quit game" });    
    }

    return items;
}

int[] makeAICarRoster(int count) {
    // Create pool of valid AI car indices
    int[] pool = new int[aiCarNames.length];
    for (int i = 0; i < aiCarNames.length; i++) {
        pool[i] = i;
    }

    // Build roster by selecting cars randomly from the pool
    int[] roster = new int[0];
    while (roster.length < count) {
        int i = rnd() * pool.length;
        roster.add(pool[i]);
        pool.remove(i);
    }

    return roster;
}

void startRace(RaceParams raceParams) {

    // Save settings
    saveConfig();
    saveTournament();

    // Set race params
    race = raceParams;

    // Switch to race mode
    setGameMode(GAMEMODE_RACE);
}

void doDemo() { 
    startRace(new RaceParams {
        track = tracks[rnd() * tracks.length],
        laps = 1,
        difficulty = difficultyLevels[2],
        aiCarRoster = makeAICarRoster(AI_CAR_COUNT),
        playerColour = rnd() * playerCarPalettes.length,
        isDemo = true
    });
}