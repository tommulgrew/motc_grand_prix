#include "library/trig"
#include "library/util"

struct ModelPoly {
    Texture texture;
    int colour;
    Vec pos;
    Vec size;
}

struct ModelSegment {
    ModelPoly[] frontPolys, horizPolys, vertPolys;
}

struct NestedModel;

struct Model {
    string name;
    bool isModel;       // TODO: Is this used?
    bool hasPolys;
    float minX, maxX;
    ModelSegment[] segments;
    NestedModel[] nestedModels;
}

struct NestedModel {
    // "model" reference cannot be resolved until all models are built, so name
    // is stored in the meantime.
    string modelName;
    Model model;
    Vec pos;
}

Model makeModel(string name, string data) {
    Model model = new Model { 
        name = name,
        isModel = true,
        segments = new ModelSegment[0],
        nestedModels = new NestedModel[0],
        minX = 999,
        maxX = -999
    };

    // Parse data
    string[] dataLines = split(data, "\n");
    for (string l : dataLines) {
        // Split line 
        string[] p = split(l, ",");

        // Extract data
        string type = p[0];

        string assetName = p[1];

        // Nested models may specify just some (or none)
        // of the offset coordinates.
        Vec pos = new Vec;
        if (p.length >= 3) pos.x = tofloat(p[2]);
        if (p.length >= 4) pos.y = tofloat(p[3]);
        if (p.length >= 5) pos.z = tofloat(p[4]);

        if (type = "m") {

            // Add nested model.
            // Reference by name for now. Model reference will be resolved 
            // later, after all models have been parsed.
            NestedModel nestedModel = new NestedModel {
                modelName = removePrefix(assetName, "mdl."),
                pos = pos
            };
            model.nestedModels.add(nestedModel);
        }
        else {

            // Polygon
            model.hasPolys = true;

            int colour;
            Texture texture;
            if (isNumber(assetName)) {
                // Numbers reference solid colours
                colour = toint(assetName);
            }
            else {
                // Otherwise is texture name reference
                string textureName = removePrefix(assetName, "tex.");
                texture = getTexture(textureName);
            }

            Vec size = new Vec {
                x = tofloat(p[5]),
                y = tofloat(p[6])
            };

            // Create model poly
            ModelPoly poly = new ModelPoly {
                colour = colour,
                texture = texture,
                pos = pos,
                size = size
            };

            // Z range
            float minZ = pos.z;
            float maxZ = minZ;
            if (type = "h") maxZ += size.y;
            if (type = "v") maxZ += size.x;
            if (type = "f") maxZ++;
            
            // Add poly to segments
            for (int z = minZ; z < maxZ; z++) {

                // Ensure segment exists for Z
                while (model.segments.length <= z) {
                    model.segments.add(new ModelSegment {
                        frontPolys = new ModelPoly[0],
                        horizPolys = new ModelPoly[0],
                        vertPolys = new ModelPoly[0]
                    });
                }

                // Get segment for Z
                ModelSegment segment = model.segments[z];

                if (type = "f") {
                    segment.frontPolys.add(poly);
                }
                else if (type = "h") {
                    segment.horizPolys.add(poly);
                }
                else if (type = "v") {
                    segment.vertPolys.add(poly);
                }
                else {
                    assert(false);
                }
            }

            // Adjust X range
            float w = type = "v" ? 0 : size.x / 2;
            model.minX = min(model.minX, pos.x - w);
            model.maxX = max(model.maxX, pos.x + w);
        }
    }

    return model;
}

Model[] models = new Model[] {
makeModel("road","h,tex.road00,0,0,0,8,100"),
makeModel("cpy_short",
"h,tex.cpy_under,0,-8,0,12,10\
v,tex.cpy_side,-6,-7,0,10,2\
v,tex.cpy_side, 6,-7,0,10,2\
f,tex.polev,0,-4,2,0.4,8\
f,tex.polev,0,-4,7,0.4,8"),
makeModel("canopy",
"m,mdl.cpy_short\
m,mdl.cpy_short,0,0,10"),
makeModel("cpy_wide",
"h,tex.cpy_under,0,-8,0,20,20\
v,tex.cpy_side,-10,-7,0,20,2\
v,tex.cpy_side, 10,-7,0,20,2\
f,tex.polev,0,-4,2,0.4,8\
f,tex.polev,0,-4,6,0.4,8\
f,tex.polev,0,-4,10,0.4,8\
f,tex.polev,0,-4,14,0.4,8\
f,tex.polev,0,-4,18,0.4,8"),
makeModel("dist",
"f,tex.d3,0,-.25,0,2,0.5\
f,tex.d2,0,-.25,10,2,0.5\
f,tex.d1,0,-.25,20,2,0.5"),
makeModel("shoulder","h,tex.shoulder,0,0,0,1,2"),
makeModel("stadium",
"f,tex.walla_lt,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,3,-1.5,0,20,3\
v,tex.wirefence,3,-3.5,0,20,1\
v,tex.crowd,-3,-4,0,20,2\
f,tex.walla_dk,0,-5,20,6,4\
f,5,0,-1.5,20,6,3"),
makeModel("stadium_short",
"f,tex.walla_lt,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,3,-1.5,0,10,3\
v,tex.wirefence,3,-3.5,0,10,1\
v,tex.crowd,-3,-4,0,10,2\
f,tex.walla_dk,0,-5,10,6,4\
f,5,0,-1.5,10,6,3"),
makeModel("stadiumr",
"f,tex.walla_ltr,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,-3,-1.5,0,20,3\
v,tex.wirefence,-3,-3.5,0,20,1\
v,tex.crowd,3,-4,0,20,2\
f,tex.walla_dkr,0,-5,20,6,4\
f,5,0,-1.5,20,6,3"),
makeModel("stadium_shortr",
"f,tex.walla_ltr,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,-3,-1.5,0,10,3\
v,tex.wirefence,-3,-3.5,0,10,1\
v,tex.crowd,3,-4,0,10,2\
f,tex.walla_dkr,0,-5,10,6,4\
f,5,0,-1.5,10,6,3"),
makeModel("lights",
"f,tex.lights,0,-3.25,0,3,1.5\
f,tex.poleh,11,-4.25,0,8,0.5\
f,tex.polev,15,-2,0,0.5,4\
f,tex.s_pico,0,-5,0,16,2"),
makeModel("b_pico","v,tex.b_pico,0,-0.5,0,1,1"),
makeModel("b_white","v,tex.b_white,0,-0.5,0,1,1"),
makeModel("b_redwhite","v,tex.b_redwhite,0,-0.5,0,1,1"),
makeModel("b_fence","v,tex.b_fence,0,-1.5,0,1,3"),
makeModel("tree1","f,tex.tree1,0,-3,0,6,6"),
makeModel("tree2","f,tex.tree2,0,-3,0,6,6"),
makeModel("box4x2",
"f,6,0,-1,0,4,2\
v,tex.wall_dk,-2,-1,0,4,2\
v,tex.wall_dk,2,-1,0,4,2"),
makeModel("box2x3",
"f,6,0,-1.5,0,2,3\
v,tex.wall_dk,-1,-1.5,0,2,3\
v,tex.wall_dk,1,-1.5,0,2,3"),
makeModel("box6x6x10",
"f,6,0,-3,0,6,6\
v,tex.windows4,-3,-3,0,10,6\
v,tex.windows4,3,-3,0,10,6"),
makeModel("rroof",
"f,tex.rroof,0,-3,2,4,2\
v,tex.rroof,0,-3,0,4,2"),
makeModel("redhouse",
"m,mdl.rroof\
f,6,0,-1,0,4,2\
v,tex.windows3,-2,-1,0,4,2\
v,tex.windows3,2,-1,0,4,2"),
makeModel("broof",
"f,tex.broof,0,-3,2,4,2\
v,tex.broof,0,-3,0,4,2"),
makeModel("bluehouse",
"m,mdl.broof\
f,6,0,-1,0,4,2\
v,tex.windows3,-2,-1,0,4,2\
v,tex.windows3,2,-1,0,4,2"),
makeModel("crane","f,tex.crane,0,-8.5,0,7,17"),
makeModel("sign_gravel","f,tex.s_gravel_sm,0,-0.5,0,4,1"),
makeModel("bridgesign_gravel",
"m,mdl.box2x3,-7\
m,mdl.box2x3,7\
f,8,0,-4,1,24,2\
f,tex.s_gravel,0,-4,1,4,2"),
makeModel("building1",
"f,6,0,-3,0,6,6\
v,tex.windows,-3,-3,0,10,6\
v,tex.wall_dk,3,-3,0,10,6\
h,tex.wall_lt,-4,-3,0,2,10\
v,tex.balcony,-5,-3.5,0,10,1"),
makeModel("building2",
"f,6,0,-6,0,6,12\
v,tex.windows2,-3,-6,0,10,12\
v,tex.windows2,3,-6,0,10,12\
h,tex.wall_lt,-4,-3,0,2,10\
v,tex.balcony,-5,-3.5,0,10,1\
h,tex.wall_lt,-4,-6,0,2,10\
v,tex.balcony,-5,-6.5,0,10,1"),
makeModel("marker",
"h,tex.marker,0,0,0,1,1"),
makeModel("tower",
"f,tex.towerwide,0,-10,2,2,10\
f,tex.tower,0,-2.5,2,1,5\
m,mdl.box4x2,0,-15,0\
f,6,0,-16,4,4,2"),
makeModel("sign_pico_sm",
"f,tex.s_pico_sm,0,0,0,4,1"),
makeModel("ridge",
"f,2,0,0,0,100,4")
};

Model getModel(string name) {
    for (Model model : models)
        if (model.name = name)
            return model;
    assert(false, "Could not find model: " + name);
}

void resolveNestedModelReferences() {
    for (Model model : models) {
        for (NestedModel nested : model.nestedModels) {
            nested.model = getModel(nested.modelName);
        }
    }
}

resolveNestedModelReferences();

// Common models

Model roadModel = getModel("road");
Model distSignModel = getModel("dist");
Model shoulderModel = getModel("shoulder");
Model[] treeModels = new Model[] {
    getModel("tree1"),
    getModel("tree2")
};
