#include "library/trig"
#include "library/util"

struct Material {
    int colour;
    Texture texture;
}

struct ModelPoly {
    Material material;
    Vec pos;
    Vec size;

    // Extended model poly properties
    Vec farPos;
    int side;
}

struct ModelSegment {
    ModelPoly[] frontPolys, horizPolys, vertPolys;
}

struct NestedModel;

struct Model {
    string name;
    bool isModel;       // TODO: Is this used?
    bool hasPolys;
    float minX, maxX;
    ModelSegment[] segments;
    NestedModel[] nestedModels;
}

struct NestedModel {
    // "model" reference cannot be resolved until all models are built, so name
    // is stored in the meantime.
    string modelName;
    Model model;
    Vec pos;
}

struct NestedModelEx;

struct ModelEx {
    string name;
    ModelSegment polys;
    NestedModelEx[] nestedModels;
}

struct NestedModelEx {
    string modelName;
    ModelEx model;
    Vec pos;
}

Material parseMaterial(string assetName) {
    Material material = new Material;
    if (isNumber(assetName)) {
        // Numbers reference solid colours
        material.colour = toint(assetName);
    }
    else {
        // Otherwise is texture name reference
        string textureName = removePrefix(assetName, "tex.");
        material.texture = getTexture(textureName);
    }
    return material;
}

Model makeModel(string name, string data) {
    Model model = new Model { 
        name = name,
        isModel = true,
        segments = new ModelSegment[0],
        nestedModels = new NestedModel[0],
        minX = 999,
        maxX = -999
    };

    // Parse data
    string[] dataLines = split(data, "\n");
    for (string l : dataLines) {
        // Split line 
        string[] p = split(l, ",");

        // Extract data
        string type = p[0];

        string assetName = p[1];

        // Nested models may specify just some (or none)
        // of the offset coordinates.
        Vec pos = new Vec;
        if (p.length >= 3) pos.x = tofloat(p[2]);
        if (p.length >= 4) pos.y = tofloat(p[3]);
        if (p.length >= 5) pos.z = tofloat(p[4]);

        if (type = "m") {

            // Add nested model.
            // Reference by name for now. Model reference will be resolved 
            // later, after all models have been parsed.
            NestedModel nestedModel = new NestedModel {
                modelName = removePrefix(assetName, "mdl."),
                pos = pos
            };
            model.nestedModels.add(nestedModel);
        }
        else {

            // Polygon
            model.hasPolys = true;

            Vec size = new Vec {
                x = tofloat(p[5]),
                y = tofloat(p[6])
            };

            // Create model poly
            ModelPoly poly = new ModelPoly {
                material = parseMaterial(assetName),
                pos = pos,
                size = size
            };

            // Z range
            float minZ = pos.z;
            float maxZ = minZ;
            if (type = "h") maxZ += size.y;
            if (type = "v") maxZ += size.x;
            if (type = "f") maxZ++;
            
            // Add poly to segments
            for (int z = minZ; z < maxZ; z++) {

                // Ensure segment exists for Z
                while (model.segments.length <= z) {
                    model.segments.add(new ModelSegment {
                        frontPolys = new ModelPoly[0],
                        horizPolys = new ModelPoly[0],
                        vertPolys = new ModelPoly[0]
                    });
                }

                // Get segment for Z
                ModelSegment segment = model.segments[z];

                if (type = "f") {
                    segment.frontPolys.add(poly);
                }
                else if (type = "h") {
                    segment.horizPolys.add(poly);
                }
                else if (type = "v") {
                    segment.vertPolys.add(poly);
                }
                else {
                    assert(false);
                }
            }

            // Adjust X range
            float w = type = "v" ? 0 : size.x / 2;
            model.minX = min(model.minX, pos.x - w);
            model.maxX = max(model.maxX, pos.x + w);
        }
    }

    return model;
}

Model[] models = new Model[] {
makeModel("road","h,tex.road00,0,0,0,8,100"),
makeModel("cpy_short",
"h,tex.cpy_under,0,-8,0,12,10\
v,tex.cpy_side,-6,-7,0,10,2\
v,tex.cpy_side, 6,-7,0,10,2\
f,tex.polev,0,-4,2,0.4,8\
f,tex.polev,0,-4,7,0.4,8"),
makeModel("canopy",
"m,mdl.cpy_short\
m,mdl.cpy_short,0,0,10"),
makeModel("cpy_wide",
"h,tex.cpy_under,0,-8,0,20,20\
v,tex.cpy_side,-10,-7,0,20,2\
v,tex.cpy_side, 10,-7,0,20,2\
f,tex.polev,0,-4,2,0.4,8\
f,tex.polev,0,-4,6,0.4,8\
f,tex.polev,0,-4,10,0.4,8\
f,tex.polev,0,-4,14,0.4,8\
f,tex.polev,0,-4,18,0.4,8"),
makeModel("dist",
"f,tex.d3,0,-.25,0,2,0.5\
f,tex.d2,0,-.25,10,2,0.5\
f,tex.d1,0,-.25,20,2,0.5"),
makeModel("shoulder","h,tex.shoulder,0,0,0,1,2"),
makeModel("stadium",
"f,tex.walla_lt,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,3,-1.5,0,20,3\
v,tex.wirefence,3,-3.5,0,20,1\
v,tex.crowd,-3,-4,0,20,2\
f,tex.walla_dk,0,-5,20,6,4\
f,5,0,-1.5,20,6,3"),
makeModel("stadium_short",
"f,tex.walla_lt,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,3,-1.5,0,10,3\
v,tex.wirefence,3,-3.5,0,10,1\
v,tex.crowd,-3,-4,0,10,2\
f,tex.walla_dk,0,-5,10,6,4\
f,5,0,-1.5,10,6,3"),
makeModel("stadiumr",
"f,tex.walla_ltr,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,-3,-1.5,0,20,3\
v,tex.wirefence,-3,-3.5,0,20,1\
v,tex.crowd,3,-4,0,20,2\
f,tex.walla_dkr,0,-5,20,6,4\
f,5,0,-1.5,20,6,3"),
makeModel("stadium_shortr",
"f,tex.walla_ltr,0,-5,0,6,4\
f,6,0,-1.5,0,6,3\
v,tex.graywall,-3,-1.5,0,10,3\
v,tex.wirefence,-3,-3.5,0,10,1\
v,tex.crowd,3,-4,0,10,2\
f,tex.walla_dkr,0,-5,10,6,4\
f,5,0,-1.5,10,6,3"),
makeModel("lights",
"f,tex.lights,0,-3.25,0,3,1.5\
f,tex.poleh,11,-4.25,0,8,0.5\
f,tex.polev,15,-2,0,0.5,4\
f,tex.s_pico,0,-5,0,16,2"),
makeModel("b_pico","v,tex.b_pico,0,-0.5,0,1,1"),
makeModel("b_white","v,tex.b_white,0,-0.5,0,1,1"),
makeModel("b_redwhite","v,tex.b_redwhite,0,-0.5,0,1,1"),
makeModel("b_fence","v,tex.b_fence,0,-1.5,0,1,3"),
makeModel("tree1","f,tex.tree1,0,-3,0,6,6"),
makeModel("tree2","f,tex.tree2,0,-3,0,6,6"),
makeModel("box4x2",
"f,6,0,-1,0,4,2\
v,tex.wall_dk,-2,-1,0,4,2\
v,tex.wall_dk,2,-1,0,4,2"),
makeModel("box2x3",
"f,6,0,-1.5,0,2,3\
v,tex.wall_dk,-1,-1.5,0,2,3\
v,tex.wall_dk,1,-1.5,0,2,3"),
makeModel("box6x6x10",
"f,6,0,-3,0,6,6\
v,tex.windows4,-3,-3,0,10,6\
v,tex.windows4,3,-3,0,10,6"),
makeModel("rroof",
"f,tex.rroof,0,-3,2,4,2\
v,tex.rroof,0,-3,0,4,2"),
makeModel("redhouse",
"m,mdl.rroof\
f,6,0,-1,0,4,2\
v,tex.windows3,-2,-1,0,4,2\
v,tex.windows3,2,-1,0,4,2"),
makeModel("broof",
"f,tex.broof,0,-3,2,4,2\
v,tex.broof,0,-3,0,4,2"),
makeModel("bluehouse",
"m,mdl.broof\
f,6,0,-1,0,4,2\
v,tex.windows3,-2,-1,0,4,2\
v,tex.windows3,2,-1,0,4,2"),
makeModel("crane","f,tex.crane,0,-8.5,0,7,17"),
makeModel("sign_gravel","f,tex.s_pool,0,-0.5,0,6,3"),
makeModel("bridgesign_whiplash_taxi",
"m,mdl.box2x3,-7\
m,mdl.box2x3,7\
f,tex.s_whiplash_taxi,0,-4,1,24,2"),
makeModel("building1",
"f,6,0,-3,0,6,6\
v,tex.windows,-3,-3,0,10,6\
v,tex.wall_dk,3,-3,0,10,6\
h,tex.wall_lt,-4,-3,0,2,10\
v,tex.balcony,-5,-3.5,0,10,1"),
makeModel("building2",
"f,6,0,-6,0,6,12\
v,tex.windows2,-3,-6,0,10,12\
v,tex.windows2,3,-6,0,10,12\
h,tex.wall_lt,-4,-3,0,2,10\
v,tex.balcony,-5,-3.5,0,10,1\
h,tex.wall_lt,-4,-6,0,2,10\
v,tex.balcony,-5,-6.5,0,10,1"),
makeModel("marker",
"h,tex.marker,0,0,0,1,1"),
makeModel("tower",
"f,tex.towerwide,0,-10,2,2,10\
f,tex.tower,0,-2.5,2,1,5\
m,mdl.box4x2,0,-15,0\
f,6,0,-16,4,4,2"),
makeModel("sign_pico_sm",
"f,tex.s_pico_sm,0,0,0,4,1"),
makeModel("ridge",
"f,2,0,0,0,100,4")
};

Model getModel(string name) {
    for (Model model : models)
        if (model.name = name)
            return model;
    assert(false, "Could not find model: " + name);
}

ModelEx makeModelEx(string name, string data) {
    ModelEx model = new ModelEx {
        name = name,
        polys = new ModelSegment {
            frontPolys = new ModelPoly[0],
            horizPolys = new ModelPoly[0],
            vertPolys = new ModelPoly[0]
        },
        nestedModels = new NestedModelEx[0]
    };

    // Parse data
    string[] dataLines = split(data, "\n");
    for (string l : dataLines) {
        // Split line 
        string[] p = split(l, ",");

        // Defaults
        Vec size = new Vec { x = 1, y = 1 };

        // Extract data
        string type = p[0];

        string assetName = p[1];

        if (p[2] != "") size.x = tofloat(p[2]);
        if (p[3] != "") size.y = tofloat(p[3]);

        Vec pos = new Vec {
            x = tofloat(p[4]),
            y = tofloat(p[5]),
            z = tofloat(p[6])
        };

        Vec farPos;
        
        if (p.length > 9) {
            farPos = new Vec {
                x = tofloat(p[7]),
                y = tofloat(p[8]),
                z = tofloat(p[9])
            };
        }

        int side;
        if (p.length > 10) {
            side = p[10] = "true"  ?  1
                 : p[10] = "false" ? -1
                 :                    0;
        }

        if (type = "m") {
            // Add nested extended model.
            // Reference by name for now. Model reference will be resolved 
            // later, after all models have been parsed.
            NestedModelEx nestedModel = new NestedModelEx {
                modelName = removePrefix(assetName, "mdlx."),
                pos = pos
            };
            model.nestedModels.add(nestedModel);
        }
        else {
            // Polygon

            // Create model poly
            ModelPoly poly = new ModelPoly {
                material = parseMaterial(assetName),
                pos = pos,
                farPos = farPos,
                size = size,
                side = side
            };

            // Add to polys
            if (type = "f") {
                model.polys.frontPolys.add(poly);
            }
            else if (type = "h") {
                model.polys.horizPolys.add(poly);                
            }
            else if (type = "v") {
                model.polys.vertPolys.add(poly);
            }
            else {
                assert(false);
            }
        }
    }

    return model;
}

ModelEx[] extendedModels = new ModelEx[] {
makeModelEx("car_wing",
"h,tex.car_wing_green,5,,0,0,0,0,0,1.8"),
makeModelEx("car_w",
"v,tex.car_w,,2,-0.5,0,-1,-0.5,0,1,false\
h,tex.car_w_vert,1,,0,-0.5,-0.8,0,-1,0\
h,tex.car_w_vert,1,,0,0.5,-0.8,0,1,0\
f,tex.car_w_vert,1,1,0,0,-0.8\
v,tex.car_w,,2,0.5,0,-1,0.5,0,1,true"),
makeModelEx("car_nose",
"v,tex.car_bd,,2,0,0,0,0,0.4,8"),
makeModelEx("car_bd",
"v,tex.car_bd_side,,1,-1.5,0,-1,-1.5,0,3,false\
v,tex.car_bd_side,,1,1.5,0,-1,1.5,0,3,true\
h,tex.car_bd_top,3,,0,-0.5,-1,0,-0.5,3,false\
f,tex.car_rear,3,1,0,0,-1"),
makeModelEx("car_contour",
"f,tex.car_contour,1.4,1,0,-1,-0.5"),
makeModelEx("car_tail_l",
"v,tex.car_tail_side,,1.5,-1.5,-1.25,-1,-1.5,-1.25,-0.5"),
makeModelEx("car_tail_r",
"v,tex.car_tail_side,,1.5,1.5,-1.25,-1,1.5,-1.25,-0.5"),
makeModelEx("car_tail_t",
"h,tex.car_wing_white,3,,0,-2,-1,0,-1.75,-0.5"),
makeModelEx("car",
"m,mdlx.car_wing,,,0,0.5,4\
m,mdlx.car_w,,,-2.25,0,3\
m,mdlx.car_w,,,2.25,0,3\
m,mdlx.car_nose,,,0,0,0\
m,mdlx.car_w,,,-2.25,0,0\
m,mdlx.car_w,,,2.25,0,0\
m,mdlx.car_bd,,,0,0,0\
m,mdlx.car_tail_l,,,0,0,0\
m,mdlx.car_tail_t,,,0,0,0\
m,mdlx.car_tail_r,,,0,0,0")
};

ModelEx getExtendedModel(string name) {
    for (ModelEx model : extendedModels)
        if (model.name = name)
            return model;
    assert(false, "Could not find extended model: " + name);
}

void resolveNestedModelReferences() {
    for (Model model : models) {
        for (NestedModel nested : model.nestedModels) {
            nested.model = getModel(nested.modelName);
        }
    }
    for (ModelEx model : extendedModels) {
        for (NestedModelEx nested : model.nestedModels) {
            nested.model = getExtendedModel(nested.modelName);
        }
    }
}

resolveNestedModelReferences();

// Common models

struct GameModels {
    Model roadModel, distSignModel, shoulderModel;
    Model[] treeModels;
}

GameModels gameModels = new GameModels {
    roadModel = getModel("road"),
    distSignModel = getModel("dist"),
    shoulderModel = getModel("shoulder"),
    treeModels = new Model[] {
        getModel("tree1"),
        getModel("tree2")
    }
};

struct CarModels {
    ModelEx tailLeft, tailRight, tailTop, contour, body, wing, nose, wheel;
}

CarModels carModels = new CarModels {
    tailLeft = getExtendedModel("car_tail_l"),
    tailRight = getExtendedModel("car_tail_r"),
    tailTop = getExtendedModel("car_tail_t"),
    contour = getExtendedModel("car_contour"),
    body = getExtendedModel("car_bd"),
    wing = getExtendedModel("car_wing"),
    nose = getExtendedModel("car_nose"),
    wheel = getExtendedModel("car_w")    
};
