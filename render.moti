// Constants

const int DRAW_DISTANCE = 40;
const int SCREEN_WIDTH = 320;
const int SCREEN_HEIGHT = 240;
const int CLIP_BOTTOM = 240;
const float NEAR_Z = 0.1;
const float SCREEN_DIST = SCREEN_WIDTH / 2;     // Used for projection calculations
const int TEXTURE_SCALE_FACTOR = 16;            // x8 and then x2 as resolution has been doubled

// Routines

// Project a 3D point to the screen
Vec project(Vec pt) {
    assert(pt.z >= NEAR_Z);

    float scale = SCREEN_DIST / pt.z;
    return new Vec { 
        x = pt.x * scale + SCREEN_WIDTH / 2,
        y = pt.y * scale + SCREEN_HEIGHT / 2,
        z = scale
    };
}

// Draw a textured quad, aligned such that constant z lines are horizontal
void drawQuadHoriz(
    Texture texture,
    float width,
    Vec pos0,
    Vec pos1,
    float v0, 
    float v1) {

    if (pos1.z <= NEAR_Z or pos1.z <= pos0.z) return;

    // Convert texture coords
    v0 = texture.v + texture.h * v0;        // TODO: Flip?
    v1 = texture.v + texture.h * v1;
    float u0 = texture.u;
    float u1 = texture.u + texture.w;
    v0 *= TEXTURE_SCALE_FACTOR;
    v1 *= TEXTURE_SCALE_FACTOR;
    u0 *= TEXTURE_SCALE_FACTOR;
    u1 *= TEXTURE_SCALE_FACTOR;

    // Clip to near plane
    if (pos0.z < NEAR_Z) {
        float deltaZ = pos1.z - pos0.z;
        Vec deltaPos = (pos1 - pos0) / deltaZ;
        float deltaV = (v1 - v0) / deltaZ;
        float offset = NEAR_Z - pos0.z;
        pos0  += deltaPos * offset;
        v0 += deltaV   * offset;
        pos0.z = NEAR_Z;     // Would be redundant if not for floating point error
    }

    // Project points to screen
    Vec pt0 = project(pos0);
    Vec pt1 = project(pos1);

    // Divide texture v by z (actually z/SCREEN_DIST, but this is fine)
    v0 *= pt0.z;        // (Projected z stores SCREEN_DIST/z)
    v1 *= pt1.z;

    // Swap ends if necessary to ensure pt0 is above pt1
    if (pt0.y > pt1.y) {
        Vec tempP = pt0;
        pt0 = pt1;
        pt1 = tempP;
        float tempv = v0;
        v0 = v1;
        v1 = tempv;
    }

    // Clip vertical range
    float y0 = max(ceil(pt0.y), 0);
    float y1 = min(ceil(pt1.y), CLIP_BOTTOM);
    if (y1 <= y0) return;

    // p and t delta, per raster line
    float ph = pt1.y - pt0.y;
    Vec dp = (pt1 - pt0) / ph;
    float dv = (v1 - v0) / ph;

    // Adjust p0 and t0 for clipped y0
    float yAdj = y0 - pt0.y;
    pt0 += yAdj * dp;
    v0 += yAdj * dv;

    // Draw raster lines
    tran(texture.tran);
    while (y0 < y1) {
        float pw = width * pt0.z;        // Projected width
        float v = v0 / pt0.z;            // Multiply z back into texture coord

        // Draw textured line
        texlineh(textureImage, pt0.x - pw / 2, y0, pw, u0, v, (u1 - u0) / pw, 0);

        // Next line
        y0++;
        pt0 += dp;
        v0 += dv;
    }
}

