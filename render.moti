// Constants

const int SCREEN_WIDTH = 320;
const int SCREEN_HEIGHT = 240;
const float PRATIO = SCREEN_WIDTH / 320.0;      // Pixel ratio compared to 320x240 view
const int CLIP_BOTTOM = SCREEN_HEIGHT;
const float NEAR_Z = 0.1;
const float SCREEN_DIST = SCREEN_WIDTH / 2;     // Used for projection calculations

// Routines

// Project a 3D point to the screen
Vec project(Vec pt) {
    assert(pt.z >= NEAR_Z);

    float scale = SCREEN_DIST / pt.z;
    return new Vec { 
        x = pt.x * scale + SCREEN_WIDTH / 2,
        y = pt.y * scale + SCREEN_HEIGHT / 2,
        z = scale
    };
}

// Shorthand to scale a texture with scaleimg
void scaleTexture(Texture tex, float x, float y, float w, float h, bool flipx = false) {
    tran(tex.tran);
    if (flipx) {
        scaleimg(textureImage, x, y, w, h, tex.u + tex.w - 0.001, tex.v, -tex.w, tex.h);
    }
    else {
        scaleimg(textureImage, x, y, w, h, tex.u, tex.v, tex.w, tex.h);    
    }
    tran(-1);
}

// Draw a textured quad, aligned such that constant z lines are horizontal
void drawQuadHoriz(
    Texture texture,
    float width,
    Vec pos0,
    Vec pos1,
    float v0, 
    float v1) {

    if (pos1.z <= NEAR_Z or pos1.z <= pos0.z) return;

    // Convert texture coords
    v0 = texture.v + texture.h * (1 - v0);
    v1 = texture.v + texture.h * (1 - v1);
    float u0 = texture.u;
    float u1 = texture.u + texture.w;
    v0 -= 0.001;
    v1 += 0.001;

    // Clip to near plane
    if (pos0.z < NEAR_Z) {
        float deltaZ = pos1.z - pos0.z;
        Vec deltaPos = (pos1 - pos0) / deltaZ;
        float deltaV = (v1 - v0) / deltaZ;
        float offset = NEAR_Z - pos0.z;
        pos0  += deltaPos * offset;
        v0 += deltaV   * offset;
        pos0.z = NEAR_Z;     // Would be redundant if not for floating point error
    }

    // Project points to screen
    Vec pt0 = project(pos0);
    Vec pt1 = project(pos1);

    // Divide texture v by z (actually z/SCREEN_DIST, but this is fine)
    v0 *= pt0.z;        // (Projected z stores SCREEN_DIST/z)
    v1 *= pt1.z;

    // Swap ends if necessary to ensure pt0 is above pt1
    if (pt0.y > pt1.y) {
        Vec tempP = pt0;
        pt0 = pt1;
        pt1 = tempP;
        float tempv = v0;
        v0 = v1;
        v1 = tempv;
    }

    // Clip vertical range
    float y0 = max(ceil(pt0.y), 0);
    float y1 = min(ceil(pt1.y), CLIP_BOTTOM);
    if (y1 <= y0) return;

    // p and v delta, per raster line
    float ph = pt1.y - pt0.y;
    Vec dp = (pt1 - pt0) / ph;
    float dv = (v1 - v0) / ph;

    // Adjust p0 and v0 for clipped y0
    float yAdj = y0 - pt0.y;
    pt0 += yAdj * dp;
    v0 += yAdj * dv;

    // Draw raster lines
    tran(texture.tran);
    while (y0 < y1) {
        float pw = width * pt0.z;        // Projected width
        float v = v0 / pt0.z;            // Multiply z back into texture coord

        // Draw textured line
        texlineh(textureImage, pt0.x - pw / 2, y0, pw, u0, v, (u1 - u0) / pw, 0);

        // Next line
        y0++;
        pt0 += dp;
        v0 += dv;
    }
    tran(-1);
}

void drawQuadVert(
    Texture texture,
    float height,
    Vec pos0,
    Vec pos1,
    float u0,
    float u1) {

    if (pos1.z <= NEAR_Z or pos1.z <= pos0.z) return;

    // Convert texture coords
    u0 = texture.u + texture.w * (1 - u0);
    u1 = texture.u + texture.w * (1 - u1);
    float v0 = texture.v;
    float v1 = texture.v + texture.h;
    u0 -= 0.001;
    u1 += 0.001;

    // Clip to near plane
    if (pos0.z < NEAR_Z) {
        float deltaZ = pos1.z - pos0.z;
        Vec deltaPos = (pos1 - pos0) / deltaZ;
        float deltaU = (u1 - u0) / deltaZ;
        float offset = NEAR_Z - pos0.z;
        pos0  += deltaPos * offset;
        u0    += deltaU   * offset;
        pos0.z = NEAR_Z;     // Would be redundant if not for floating point error
    }

    // Project points to screen
    Vec pt0 = project(pos0);
    Vec pt1 = project(pos1);

    // Divide texture u by z (actually z/SCREEN_DIST, but this is fine)
    u0 *= pt0.z;        // (Projected z stores SCREEN_DIST/z)
    u1 *= pt1.z;

    // Swap ends if necessary to ensure pt0 is left of pt1
    if (pt0.x > pt1.x) {
        Vec tempP = pt0;
        pt0 = pt1;
        pt1 = tempP;
        float tempu = u0;
        u0 = u1;
        u1 = tempu;
    }

    // Clip horizontal range
    float x0 = max(ceil(pt0.x), 0);
    float x1 = min(ceil(pt1.x), SCREEN_WIDTH);
    if (x1 <= x0) return;

    // p and u delta, per vertical raster line
    float pw = pt1.x - pt0.x;       // Projected width
    Vec dp = (pt1 - pt0) / pw;
    float du = (u1 - u0) / pw;

    // Adjust p0 and v0 for clipped x0
    float xAdj = x0 - pt0.x;
    pt0 += xAdj * dp;
    u0 += xAdj * du;

    // Draw raster lines
    tran(texture.tran);
    while (x0 < x1) {
        float ph = height * pt0.z;       // Projected height
        float u = u0 / pt0.z;            // Multiply z back into texture coord

        // Draw textured line
        texlinev(textureImage, x0, pt0.y - ph / 2, ph, u, v0, 0, (v1 - v0) / ph);

        // Next line
        x0++;
        pt0 += dp;
        u0 += du;
    }
    tran(-1);
}

void drawQuadFront(
    Texture texture,
    int colour,
    float width,
    float height,
    Vec pos,
    bool flipX) {

    if (pos.z < NEAR_Z) return;

    // Project
    Vec pt = project(pos);
    width *= pt.z;
    height *= pt.z;

    float x0 = pt.x - width / 2,
        x1 = pt.x + width / 2,
        y0 = pt.y - height / 2,
        y1 = pt.y + height / 2;

    if (texture != null) {
        scaleTexture(texture, x0, y0, width, height, flipX);
    }
    else {
        color(colour);
        rectfill(x0, y0, x1, y1);
    }
}
