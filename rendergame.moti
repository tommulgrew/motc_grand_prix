#include "tracks"
#include "gamedata"
#include "routines"
#include "render"

// Constants

const int DRAW_DISTANCE = 60;
const float CAMERA_TILT = 0.175;

// Structures

struct ScreenSpaceSegment {
    WorldSegment segment;       // Corresponding world segment
    Vec pos;                    // Screen space position
    float turn, pitch;          // Screen space turn and pitch
    float clipY;
    int zIndex;                 // Index of segment in world array
}

// Data

Vec playerCameraOffset = new Vec {
    y = -0.6
};

// Routines

void drawWorld(Vec cameraPos, float cameraTurn, float cameraPitch, int drawDistance, Track track);
void drawCockpit();

void drawGame(Track track) {
    drawWorld(
        player.pos + playerCameraOffset, 
        player.turn, 
        player.pitch, 
        DRAW_DISTANCE, 
        track);
    drawCockpit();
}

ScreenSpaceSegment[] getScreenSpaceSegments(Vec cameraPos, float cameraTurn, float cameraPitch, int drawDistance) {
    ScreenSpaceSegment[] screenSegs = new ScreenSpaceSegment[0];

    // Current world segment
    int cameraZIndex = floor(cameraPos.z);
    WorldSegment cameraSegment = world[cameraZIndex % world.length];

    // Road drawing cursor
    float turn = -cameraTurn, pitch = cameraSegment.pitch - cameraPitch - CAMERA_TILT;
    float clipY = SCREEN_HEIGHT;

    // Calculate initial position
    Vec skewedCameraPos = skew(new Vec { 
        x = cameraPos.x,
        y = cameraPos.y, 
        z = cameraPos.z - cameraZIndex        // Distance from start of segment
    }, turn, pitch);
    Vec pos = -skewedCameraPos;

    // Generate screen segment
    for (int i = 0; i < drawDistance; i++) {
        int segmentZIndex = (cameraZIndex + i) % world.length;
        WorldSegment segment = world[segmentZIndex];
        pitch = segment.pitch - cameraPitch - CAMERA_TILT;
        if (pos.z >= NEAR_Z) {
            Vec horizonPt = project(pos);
            clipY = min(horizonPt.y, clipY);
        }
        screenSegs.add(new ScreenSpaceSegment {
            segment = segment,
            pos = pos,
            turn = turn,
            pitch = pitch,
            clipY = ceil(clipY),
            zIndex = segmentZIndex
        });

        // Update position for next screen segment
        pos = pos + new Vec { x = turn, y = pitch, z = 1 };
        turn += segment.turn;
    }

    return screenSegs;
}

void drawHorizon(ScreenSpaceSegment[] screenSegs, Track track, float cameraTurn, float cameraPitch) {
    ScreenSpaceSegment lastSegment = screenSegs[screenSegs.length - 1];
    float hx = horizonX + cameraTurn * SCREEN_DIST;
    float hy = SCREEN_HEIGHT / 2 - (cameraPitch * CAMERA_TILT) * SCREEN_DIST + 4;
    float groundY = min(lastSegment.clipY, hy + 8);
    
    Texture tex = gameTextures.horizon;
    float scale = PRATIO;
    float w = tex.w * scale;
    float h = tex.h * scale;
    hx -= floor(hx / w) * w;

    color(track.skyColour);
    rectfill(0, 0, SCREEN_WIDTH, groundY);

    for (float x = -hx; x < SCREEN_WIDTH; x += w) {
        scaleTexture(tex, x, groundY - h, w, h);
    }

    color(track.groundColour);
    rectfill(0, groundY, SCREEN_WIDTH, SCREEN_HEIGHT);
}

void drawScreenSpaceSegments(ScreenSpaceSegment[] screenSegs) {
    // Draw segments in reverse order
    for (int i = screenSegs.length - 2; i >= 0; i--) {
        ScreenSpaceSegment screenSeg = screenSegs[i];
        ScreenSpaceSegment nextScreenSeg = screenSegs[i + 1];

        clipregion(0, 0, SCREEN_WIDTH, screenSeg.clipY);

        // Draw model instance cross sections for this segment
        WorldSegment segment = screenSeg.segment;
        WorldSegment nextSegment = nextScreenSeg.segment;
        for (ModelInstance instance : segment.modelInstances) {
            Model model = instance.model;

            // Position of start and end of polygon
            Vec instanceOffsFromSeg = new Vec { 
                x = instance.pos.x, 
                y = instance.pos.y 
            };
            Vec instancePos0 = screenSeg.pos + instanceOffsFromSeg;
            if (instance.ref = REF_LEFT)  instancePos0 += new Vec { x = segment.left };
            if (instance.ref = REF_RIGHT) instancePos0 += new Vec { x = segment.right };
            Vec instancePos1 = nextScreenSeg.pos + instanceOffsFromSeg;
            if (instance.ref = REF_LEFT)  instancePos1 += new Vec { x = nextSegment.left };
            if (instance.ref = REF_RIGHT) instancePos1 += new Vec { x = nextSegment.right };

            // Clip if outside screen horizontal range.
            // Note: This assumes a 90 degree horizontal FOV.
            float xLimit = screenSeg.pos.z;         
            // if (instancePos0.x + model.maxX < -xLimit and instancePos1.x + model.maxX < -xLimit) continue;
            // if (instancePos0.x + model.minX >  xLimit and instancePos1.x + model.minX >  xLimit) continue;

            // Find model segment
            int instanceZIndex = instance.pos.z;
            int modelSegmentIndex = (screenSeg.zIndex - instanceZIndex) % world.length;
            if (modelSegmentIndex < 0) {
                modelSegmentIndex += world.length;
            }
            ModelSegment modelSegment = instance.length > 0
                ? model.segments[0]                         // Single segment model stretched over a specified length
                : model.segments[modelSegmentIndex];
            
            // Draw segment polygons
            for (ModelPoly poly : modelSegment.horizPolys) {

                // Texture coordinates
                // One segment = 1 tile
                Texture texture = poly.texture;
                float v0 = modelSegmentIndex * TILE_SIZE_PIXELS * 1.0 / texture.h;
                v0 -= floor(v0);        // Repeat
                float v1 = v0 + TILE_SIZE_PIXELS * 1.0 / texture.h;

                // Draw polygon
                Vec polyOffset = new Vec { x = poly.pos.x, y = poly.pos.y };
                drawQuadHoriz(
                    texture, 
                    poly.size.x, 
                    instancePos0 + polyOffset,
                    instancePos1 + polyOffset,
                    v0, v1);
            }

            for (ModelPoly poly : modelSegment.vertPolys) {

                // Texture coordinates
                // One segment = 1 tile
                Texture texture = poly.texture;
                float u0 = modelSegmentIndex * TILE_SIZE_PIXELS * 1.0 / texture.w;
                u0 -= floor(u0);
                float u1 = u0 + TILE_SIZE_PIXELS * 1.0 / texture.w;

                // Draw polygon
                Vec polyOffset = new Vec { x = poly.pos.x, y = poly.pos.y };
                drawQuadVert(
                    texture,
                    poly.size.y,
                    instancePos0 + polyOffset,
                    instancePos1 + polyOffset,
                    u0, u1);
            }

            for (ModelPoly poly : modelSegment.frontPolys) {
                Vec polyOffset = new Vec { x = poly.pos.x, y = poly.pos.y };
                drawQuadFront(
                    poly.texture,
                    poly.colour,
                    poly.size.x,
                    poly.size.y,
                    instancePos0 + polyOffset,
                    false);
            }
        }

        // TODO: Racing line

        // TODO: Other cars
    }
}

void drawWorld(Vec cameraPos, float cameraTurn, float cameraPitch, int drawDistance, Track track) {
    ScreenSpaceSegment[] screenSegs = getScreenSpaceSegments(cameraPos, cameraTurn, cameraPitch, drawDistance);
    drawHorizon(screenSegs, track, cameraTurn, cameraPitch);
    drawScreenSpaceSegments(screenSegs);
    
    clipregion();       // Clear clip region
}

void drawWheels(float steering, int wheelRotation, float scale) {

    Texture sideTex = gameTextures.wheelSide;
    Texture tireTex = gameTextures.wheelTire;

    // Wheels
    float w = steering * 16;
    float lw = 28 + w;
    float rw = 28 - w;
    float h = tireTex.h * scale;
    float lx = SCREEN_WIDTH / 2 - 120 * PRATIO;
    float rx = SCREEN_WIDTH / 2 + 120 * PRATIO;
    float y = SCREEN_HEIGHT - h - 32 * PRATIO;

    float l0 = ceil(lx - lw / 2), l1 = ceil(lx + lw / 2);
    float r0 = ceil(rx - rw / 2), r1 = ceil(rx + rw / 2);

    // Use palette cycling to animate wheel turning
    int[] wheelTurnCols = new int[16];
    for (int i = 0; i < 8; i++) {
        wheelTurnCols[i] = i;
    }
    for (int i = 0; i < 8; i++) {
        wheelTurnCols[i + 8] = wheelPalette[(wheelRotation + i) % wheelPalette.length];
    }

    colmap(wheelTurnCols);

    // Draw left wheel
    scaleTexture(tireTex, 0, y, l0, h);
    scaleTexture(sideTex, l0, y, lw, h);

    // Draw right wheel
    scaleTexture(tireTex, r1 - 1, y, SCREEN_WIDTH - r1 + 1, h);
    scaleTexture(sideTex, r0, y, rw, h, true);

    colmap(null);
}

void drawCockpit() {

    float steering = player.input.steering;

    // Calculate scale so that cockpit texture fits width of screen
    Texture cptex = gameTextures.cockpit;
    float scale = SCREEN_WIDTH * 1.0 / cptex.w;
    float cockpitWidth = SCREEN_WIDTH;
    float cockpitHeight = cptex.h * scale;

    // Wheels

    // Prevent wheels from turning more than a half turn per frame. Otherwise they
    // can appear to be stationary or rotating backwards at certain speeds.
    player.anim.wheelTurn = min(player.anim.wheelPrev + wheelPalette.length * 0.4, player.anim.wheelTurn);
    drawWheels(steering, player.anim.wheelTurn, scale);

    // Windshield circle
    color(7);
    circ(SCREEN_WIDTH / 2, SCREEN_HEIGHT - cockpitHeight * 0.6, SCREEN_WIDTH * 0.3);

    // Cockpit base image
    scaleTexture(cptex, 0, SCREEN_HEIGHT - cockpitHeight, cockpitWidth, cockpitHeight);

    // Steering wheel
    Texture swtex = gameTextures.steeringWheel;
    float steerWidth = swtex.w * scale;
    float steerHeight = swtex.h * scale;
    float steerx = SCREEN_WIDTH / 2;
    float steery = SCREEN_HEIGHT - steerHeight * 24.0 / 256;
    float ang = steering * MATH_PI / 2;
    float sa = sin(ang), ca = cos(ang);
    tran(swtex.tran);
    for (int y = floor(steery - steerHeight / 2); y < SCREEN_HEIGHT; y++) {
        
        // Texture coordinates
        float tx = (-steerWidth / 2) / scale;
        float ty = (y - steery) / scale;

        // Rotate by angle
        float rx = ca * tx + sa * ty + swtex.u + swtex.w / 2;
        float ry =-sa * tx + ca * ty + swtex.v + swtex.h / 2;

        // Draw textured line
        texlineh(textureImage, steerx - steerWidth / 2, y, steerWidth, rx, ry, 
             ca * swtex.w / steerWidth,
            -sa * swtex.h / steerWidth);
    }
    tran(-1);

    Texture ctex = gameTextures.steeringCenter;
    float centerWidth = ctex.w * scale;
    float centerHeight = ctex.h * scale;
    scaleTexture(ctex, steerx - centerWidth / 2, steery - centerHeight / 2,
        centerWidth, centerHeight);
}