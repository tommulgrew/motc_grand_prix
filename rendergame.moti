#include "tracks"
#include "gamedata"
#include "routines"
#include "render"

// Constants

const float CAMERA_TILT = 0.175;

Vec PLAYER_CAMERA_OFFSET = new Vec {    // Intended to be treated as a constant
    y = -0.6
};

string[] placeText = new string[] {
    "st",
    "nd",
    "rd",
    "th"
};

// Structures

struct CameraInfo {
    Vec pos;
    float turn;                 // Turn angle relative to current segment
    float pitch;                // Absolute pitch angle
    int segmentIndex;           // Index of first segment in world array
}

struct ScreenSpaceSegment {
    WorldSegment segment;       // Corresponding world segment
    Transform T;
    float clipY;
    int zIndex;                 // Index of segment in world array
    int index;                  // Index of segment in screen segment array
}

// Routines

void drawWorld(CameraInfo cam, int drawDistance);
void drawCockpit();
void drawMirror();
void drawHud();
void drawPreRaceText(string text);
void drawResults();

CameraInfo getCamera();
CameraInfo getPlayerCamera();

void drawGame() {

    // Draw world
    CameraInfo cam = getCamera();
    drawWorld(cam, gameConfig.drawDistance);

    if (raceMode != RACEMODE_RESULTS) {
        drawCockpit();
        if (not race.isQualificationLap) {
            drawMirror();
        }
    }
    if (raceMode = RACEMODE_PRERACE or raceMode = RACEMODE_RACING) {
        drawHud();
    }

    if (raceMode = RACEMODE_PRERACE) {

        if (race.isQualificationLap and raceSequenceTimer % 30 < 15) {
            int TEXT_Y = SCREEN_HEIGHT * 0.15;
            fancyPrint("Qualification Lap", 8, TEXT_Y, -1, 2, 5);
        }

        // Display 3..2..1
        int countDown = toint(5 - raceSequenceTimer / 30.0);
        if (countDown <= 3) {
            drawPreRaceText(countDown);
        }
    }
    else if (raceMode = RACEMODE_RACING and not race.isPracticeMode) {

        // Flash "!! GO !!" for first second
        if (raceSequenceTimer < 30 and raceSequenceTimer % 10 < 5) {
            drawPreRaceText("!! GO !!");
        }
    }
    else if (raceMode = RACEMODE_POSTRACE and not race.isDemo) {
        int TEXT_Y = SCREEN_HEIGHT * 0.2;
        fancyPrint(race.isQualificationLap ? "Qualification Finished" : "Race Finished", 9, TEXT_Y, -1, 2, 5);
        if (raceSequenceTimer > 60 and raceSequenceTimer % 30 < 15) {
            fancyPrint("Press button to continue", 9, TEXT_Y + 20, -1, 1, 5);
        }
    }
    else if (raceMode = RACEMODE_RESULTS and not race.isDemo) {
        drawResults();
        if (raceSequenceTimer > 60 and raceSequenceTimer % 30 < 15) {
            fancyPrint("Press button to continue", 9, SCREEN_HEIGHT * 0.6, -1, 1, 5);
        }
    }

    if (race.isDemo) {
        int TEXT_Y = SCREEN_HEIGHT * 0.15;
        fancyPrint("Demo", 9, TEXT_Y, -1, 2, 5);
        if (raceSequenceTimer % 30 < 15) {
            fancyPrint("Press button to quit", 9, TEXT_Y + 20, -1, 1, 5);
        }
    }
}

CameraInfo getCamera() {
    CameraInfo cam;
    if (raceMode = RACEMODE_RESULTS) {

        // Race results camera
        Vec pos = new Vec { y = -1.5, z = world.length + race.track.finishLineDistance - 30 };
        cam = new CameraInfo {
            pos = pos,
            pitch = -0.3,
            segmentIndex = getSegmentIndex(pos.z)
        };
        clipBottom = SCREEN_HEIGHT;
    }
    else {

        // Player camera
        cam = getPlayerCamera();   
        clipBottom = CAR_CLIP_BOTTOM; 
    }

    return cam;
}

CameraInfo getPlayerCamera() {
    CameraInfo cam = new CameraInfo {
        pos = player.pos,
        turn = player.turn,
        pitch = player.pitch,
        segmentIndex = getSegmentIndex(player.pos.z)
    };

    // Apply camera offset
    cam.pos += PLAYER_CAMERA_OFFSET;

    // Convert pitch from segment relative to absolute
    WorldSegment segment = getSegment(cam.segmentIndex);
    cam.pitch += segment.pitch;

    return cam;
}

ScreenSpaceSegment[] getScreenSpaceSegments(CameraInfo cam, int drawDistance) {
    ScreenSpaceSegment[] screenSegs = new ScreenSpaceSegment[0];

    // Current world segment
    WorldSegment cameraSegment = getSegment(cam.segmentIndex);

    // Road drawing cursor
    float turn = -cam.turn, pitch = cameraSegment.pitch - cam.pitch - CAMERA_TILT;
    float clipY = clipBottom;

    // Calculate initial position
    Vec skewedCameraPos = skew(segmentRelativePos(cam.pos), turn, pitch);
    Vec pos = -skewedCameraPos;

    // Generate screen segment
    for (int i = 0; i < drawDistance; i++) {
        int segmentZIndex = getSegmentIndex(cam.segmentIndex + i);
        WorldSegment segment = getSegment(segmentZIndex);
        pitch = segment.pitch - cam.pitch - CAMERA_TILT;
        if (pos.z >= NEAR_Z) {
            Vec horizonPt = project(pos);
            clipY = min(horizonPt.y, clipY);
        }
        screenSegs.add(new ScreenSpaceSegment {
            segment = segment,
            T = new Transform {
                translate = pos,
                skewX = turn, 
                skewY = pitch
            },
            clipY = ceil(clipY),
            zIndex = segmentZIndex,
            index = i
        });

        // Update position for next screen segment
        pos = pos + new Vec { x = turn, y = pitch, z = 1 };
        turn += segment.turn;
    }

    return screenSegs;
}

void drawHorizon(ScreenSpaceSegment[] screenSegs, CameraInfo cam) {
    ScreenSpaceSegment lastSegment = screenSegs[screenSegs.length - 1];
    float hx = horizonX + cam.turn * SCREEN_DIST;
    float hy = SCREEN_HEIGHT / 2 - (cam.pitch * CAMERA_TILT) * SCREEN_DIST + 4;
    float groundY = min(lastSegment.clipY, hy + 8);
    
    Texture tex = gameTextures.horizon;
    float scale = PRATIO;
    float w = tex.w * scale;
    float h = tex.h * scale;
    hx -= floor(hx / w) * w;

    color(race.track.skyColour);
    rectfill(0, 0, SCREEN_WIDTH, groundY);

    for (float x = -hx; x < SCREEN_WIDTH; x += w) {
        scaleTexture(tex, x, groundY - h, w, h);
    }

    color(race.track.groundColour);
    rectfill(0, groundY, SCREEN_WIDTH, SCREEN_HEIGHT);
}

void drawModelEx(ModelEx model, Transform T) {
    for (NestedModelEx nested : model.nestedModels) {
        drawModelEx(nested.model, childTransform(T, nested.pos));
    }

    for (ModelPoly poly : model.polys.horizPolys) {
        Vec n = T * poly.pos, f = T * poly.farPos;
        int side = -sgn(n.y / n.z - (f.y - n.y) / (f.z - n.z));
        if (poly.side = 0 or poly.side = side) {
            drawQuadHoriz(
                poly.material.texture, 
                poly.size.x,
                n,
                f,
                0, 1);
        }
    }

    for (ModelPoly poly : model.polys.vertPolys) {
        Vec n = T * poly.pos, f = T * poly.farPos;
        int side = -sgn(n.x / n.z - (f.x - n.x) / (f.z - n.z));
        if (poly.side = 0 or poly.side = side) {
            drawQuadVert(
                poly.material.texture,
                poly.size.y,
                n,
                f,
                0, 1);
        }
    }

    for (ModelPoly poly : model.polys.frontPolys) {
        drawQuadFront(
            poly.material,
            poly.size.x,
            poly.size.y,
            T * poly.pos,
            false);
    }
}

void drawCarTail(Transform T) {
    // Camera relative position
    Vec c = new Vec {
        x = -T.translate.x + T.skewX * T.translate.z,
        y = -T.translate.y + T.skewY * T.translate.z,
        z = -T.translate.z
    };

    if (c.x < 1.5) drawModelEx(carModels.tailRight, T);
    if (c.x >-1.5) drawModelEx(carModels.tailLeft, T);
    drawModelEx(carModels.contour, T);
    drawModelEx(carModels.tailTop, T);
    if (c.x>= 1.5) drawModelEx(carModels.tailRight, T);
    if (c.x<=-1.5) drawModelEx(carModels.tailLeft, T);
}

void drawCarMiddle(Transform T) {
    // Camera relative position
    Vec c = new Vec {
        x = -T.translate.x + T.skewX * T.translate.z,
        y = -T.translate.y + T.skewY * T.translate.z,
        z = -T.translate.z
    };

    if (c.y < -0.7) {
        drawModelEx(carModels.body, T);
        drawCarTail(T);
    }
    else {
        drawCarTail(T);    
        drawModelEx(carModels.body, T);
    }
}

void drawCar(Transform T) {

    // Adjust position.
    // Essentially we push the car away to scale it down.
    T = new Transform {
        translate = T.translate * 4 + new Vec { y = -0.1 },
        skewX = T.skewX,
        skewY = T.skewY        
    };

    // Camera relative position
    Vec c = new Vec {
        x = -T.translate.x + T.skewX * T.translate.z,
        y = -T.translate.y + T.skewY * T.translate.z,
        z = -T.translate.z
    };
    drawModelEx(carModels.wing, childTransform(T, new Vec { y = -0.4, z = 5 }));
    if (c.x < 1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x = 2.25, y =-1, z = 3 }));
    if (c.x >-1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x =-2.25, y =-1, z = 3 }));
    drawModelEx(carModels.nose, childTransform(T, new Vec { y = -1.3, z = -2 }));
    if (c.x>= 1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x = 2.25, y =-1, z = 3 }));
    if (c.x<=-1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x =-2.25, y =-1, z = 3 }));

    if (c.x < 1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x = 2.25, y =-1, z = -1.5 }));
    if (c.x >-1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x =-2.25, y =-1, z = -1.5 }));
    drawCarMiddle(childTransform(T, new Vec { y = -0.7, z = -1 }));
    if (c.x>= 1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x = 2.25, y =-1, z = -1.5 }));
    if (c.x<=-1.5) drawModelEx(carModels.wheel, childTransform(T, new Vec { x =-2.25, y =-1, z = -1.5 }));

}

void drawScreenSpaceSegments(ScreenSpaceSegment[] screenSegs, CameraInfo cam) {

    // Next car from sortedCars to draw
    int carIndex = 0;

    // Draw segments in reverse order
    for (int i = screenSegs.length - 2; i >= 0; i--) {
        ScreenSpaceSegment screenSeg = screenSegs[i];
        ScreenSpaceSegment nextScreenSeg = screenSegs[i + 1];

        clipregion(0, 0, SCREEN_WIDTH, screenSeg.clipY);

        // Draw model instance cross sections for this segment
        WorldSegment segment = screenSeg.segment;
        WorldSegment nextSegment = nextScreenSeg.segment;
        for (ModelInstance instance : segment.modelInstances) {
            Model model = instance.model;

            // Position of start and end of polygon
            Vec instanceOffsFromSeg = new Vec { 
                x = instance.pos.x, 
                y = instance.pos.y 
            };
            Vec instancePos0 = screenSeg.T * instanceOffsFromSeg;
            if (instance.ref = REF_LEFT)  instancePos0 += new Vec { x = segment.left };
            if (instance.ref = REF_RIGHT) instancePos0 += new Vec { x = segment.right };
            Vec instancePos1 = nextScreenSeg.T * instanceOffsFromSeg;
            if (instance.ref = REF_LEFT)  instancePos1 += new Vec { x = nextSegment.left };
            if (instance.ref = REF_RIGHT) instancePos1 += new Vec { x = nextSegment.right };

            // Clip if outside screen horizontal range.
            // Note: This assumes a 90 degree horizontal FOV.
            float xLimit = screenSeg.T.translate.z;         
            // if (instancePos0.x + model.maxX < -xLimit and instancePos1.x + model.maxX < -xLimit) continue;
            // if (instancePos0.x + model.minX >  xLimit and instancePos1.x + model.minX >  xLimit) continue;

            // Find model segment
            int instanceZIndex = instance.pos.z;
            int modelSegmentIndex = (screenSeg.zIndex - instanceZIndex) % world.length;
            if (modelSegmentIndex < 0) {
                modelSegmentIndex += world.length;
            }
            ModelSegment modelSegment = instance.length > 0
                ? model.segments[0]                         // Single segment model stretched over a specified length
                : model.segments[modelSegmentIndex];
            
            // Draw segment polygons
            for (ModelPoly poly : modelSegment.horizPolys) {

                // Texture coordinates
                // One segment = 1 tile
                Texture texture = poly.material.texture;
                float v0 = modelSegmentIndex * TILE_SIZE_PIXELS * 1.0 / texture.h;
                v0 -= floor(v0);        // Repeat
                float v1 = v0 + TILE_SIZE_PIXELS * 1.0 / texture.h;

                // Draw polygon
                Vec polyOffset = new Vec { x = poly.pos.x, y = poly.pos.y };
                drawQuadHoriz(
                    texture, 
                    poly.size.x, 
                    instancePos0 + polyOffset,
                    instancePos1 + polyOffset,
                    v0, v1);
            }

            for (ModelPoly poly : modelSegment.vertPolys) {

                // Texture coordinates
                // One segment = 1 tile
                Texture texture = poly.material.texture;
                float u0 = modelSegmentIndex * TILE_SIZE_PIXELS * 1.0 / texture.w;
                u0 -= floor(u0);
                float u1 = u0 + TILE_SIZE_PIXELS * 1.0 / texture.w;

                // Flip?
                if (texture.flipOnLeft and instance.ref = REF_LEFT) {
                    u0 = 1 - u0;
                    u1 = 1 - u1;
                }

                // Draw polygon
                Vec polyOffset = new Vec { x = poly.pos.x, y = poly.pos.y };
                drawQuadVert(
                    texture,
                    poly.size.y,
                    instancePos0 + polyOffset,
                    instancePos1 + polyOffset,
                    u0, u1);
            }

            for (ModelPoly poly : modelSegment.frontPolys) {
                Vec polyOffset = new Vec { x = poly.pos.x, y = poly.pos.y };
                drawQuadFront(
                    poly.material,
                    poly.size.x,
                    poly.size.y,
                    instancePos0 + polyOffset,
                    poly.material.texture != null 
                    and poly.material.texture.flipOnLeft 
                    and (instance.ref = REF_LEFT or (instance.ref = 0 and instanceOffsFromSeg.x < 0)));
            }

            if (gameConfig.showRacingLine and (raceMode = RACEMODE_PRERACE or raceMode = RACEMODE_RACING) and not race.isDemo) {
                if (screenSeg.zIndex % 3 = 0 and screenSeg.segment.hasAiX) {
                    float c = (player.vel - screenSeg.segment.aiVelocity * 1.1) * 25 + 1.99;
                    c = clamp(c, 0, aiMarkerCols.length - 1);
                    colmap(aiMarkerCols[c]);
                    Vec markerOffset = new Vec { x = screenSeg.segment.aiX };
                    drawQuadHoriz(
                        gameTextures.marker,
                        1,
                        screenSeg.T * markerOffset,
                        nextScreenSeg.T * markerOffset,
                        0, 1);
                    colmap();
                }                
            }

            if (not race.isQualificationLap) {
                float segRelZ = screenSeg.zIndex - cam.pos.z;
                segRelZ -= floor(segRelZ / world.length) * world.length;
                while (carIndex < sortedCars.length and sortedCars[carIndex].relZ >= segRelZ) {
                    Car car = sortedCars[carIndex];
                    if (car.relZ < segRelZ + 1 && car != player) {
                        colmap(aiCarPalettes[car.carIndex]);
                        drawCar(
                            new Transform {
                                translate = screenSeg.T * (segmentRelativePos(car.pos) + new Vec { z = -0.2 }),
                                skewX = screenSeg.T.skewX + car.turn,
                                skewY = screenSeg.T.skewY + car.pitch
                            });
                        colmap();
                    }
                    carIndex++;
                }
            }
        }
    }
}

void drawWorld(CameraInfo cam, int drawDistance) {
    sortCars(cam.pos.z);
    ScreenSpaceSegment[] screenSegs = getScreenSpaceSegments(cam, drawDistance);
    drawHorizon(screenSegs, cam);
    drawScreenSpaceSegments(screenSegs, cam);
    
    clipregion();       // Clear clip region
}

void drawWheels(float steering, int wheelRotation, float scale) {

    Texture sideTex = gameTextures.wheelSide;
    Texture tireTex = gameTextures.wheelTire;

    // Wheels
    float w = steering * 16;
    float lw = (28 + w) * PRATIO;
    float rw = (28 - w) * PRATIO;
    float h = tireTex.h * scale;
    float lx = SCREEN_WIDTH / 2 - 120 * PRATIO;
    float rx = SCREEN_WIDTH / 2 + 120 * PRATIO;
    float y = SCREEN_HEIGHT - h - 32 * PRATIO + player.anim.suspension * PRATIO;

    float l0 = ceil(lx - lw / 2), l1 = ceil(lx + lw / 2);
    float r0 = ceil(rx - rw / 2), r1 = ceil(rx + rw / 2);

    // Use palette cycling to animate wheel turning
    int[] wheelTurnCols = new int[16];
    for (int i = 0; i < 8; i++) {
        wheelTurnCols[i] = i;
    }
    for (int i = 0; i < 8; i++) {
        wheelTurnCols[i + 8] = wheelPalette[(wheelRotation + i) % wheelPalette.length];
    }

    colmap(wheelTurnCols);

    // Draw left wheel
    scaleTexture(tireTex, 0, y, l0, h);
    scaleTexture(sideTex, l0, y, lw, h);

    // Draw right wheel
    scaleTexture(tireTex, r1 - 1, y, SCREEN_WIDTH - r1 + 1, h);
    scaleTexture(sideTex, r0, y, rw, h, true);

    colmap(null);
}

void drawCockpit() {

    float steering = player.input.steering;

    // Calculate scale so that cockpit texture fits width of screen
    Texture cptex = gameTextures.cockpit;
    float scale = SCREEN_WIDTH * 1.0 / cptex.w;
    float cockpitWidth = SCREEN_WIDTH;
    float cockpitHeight = cptex.h * scale;

    // Wheels

    // Prevent wheels from turning more than a half turn per frame. Otherwise they
    // can appear to be stationary or rotating backwards at certain speeds.
    player.anim.wheelTurn = min(player.anim.wheelPrev + wheelPalette.length * 0.4, player.anim.wheelTurn);
    drawWheels(steering, player.anim.wheelTurn, scale);

    // Windshield circle
    color(7);
    circ(SCREEN_WIDTH / 2, SCREEN_HEIGHT - cockpitHeight * 0.6, SCREEN_WIDTH * 0.3);

    // Cockpit base image
    colmap(playerCarPalettes[race.playerColour]);
    scaleTexture(cptex, 0, SCREEN_HEIGHT - cockpitHeight, cockpitWidth, cockpitHeight);
    colmap();

    { 
        // Speed readout
        float sx = SCREEN_WIDTH / 2 - 54 * PRATIO;
        float sy = SCREEN_HEIGHT - 92 * PRATIO;
        float sw = 21 * PRATIO;
        float sh = 10 * PRATIO;
        color(0);
        rectfill(sx, sy, sx + sw, sy + sh);
        color(5);
        rect(sx, sy, sx + sw, sy + sh);
        string txt = toint(player.vel * 600);
        while (txt.length < 3) txt = "0" + txt;
        color(8);
        print(txt, sx + 1 * PRATIO, sy + 2 * PRATIO);

        // Speed bar
        float sgx = sx + sw + 5 * PRATIO;
        float sgw = 83 * PRATIO;
        color(0);
        rectfill(sgx, sy, sgx + sgw, sy + sh);
        color(5);
        rect(sgx, sy, sgx + sgw, sy + sh);
        int barWidth = min(player.vel * 230, 80);
        for (int i = 0; i < barWidth; i += 4) {
            color(i < 50 ? 11
                : i < 70 ? 9
                :          8);
            rectfill(
                sgx + (2 + i) * PRATIO,
                sy + 2 * PRATIO,
                sgx + (2 + i + 3) * PRATIO,
                sy + sh - 2 * PRATIO);
        }
    }

    // Revs needle
    {
        float ra = MATH_PI * 2;
        float sr = sin(player.anim.revs * ra), cr = cos(player.anim.revs * ra);
        float rx = SCREEN_WIDTH / 2;
        float ry = SCREEN_HEIGHT - 41 * PRATIO;
        color(9);
        line(rx, ry, rx - sr * 20 * PRATIO, ry + cr * 16 * PRATIO);
    }

    // Steering wheel
    Texture swtex = gameTextures.steeringWheel;
    float steerWidth = swtex.w * scale;
    float steerHeight = swtex.h * scale;
    float steerx = SCREEN_WIDTH / 2;
    float steery = SCREEN_HEIGHT - steerHeight * 24.0 / 256;
    float ang = steering * MATH_PI / 2;
    float sa = sin(ang), ca = cos(ang);
    tran(swtex.tran);
    for (int y = floor(steery - steerHeight / 2); y < SCREEN_HEIGHT; y++) {
        
        // Texture coordinates
        float tx = (-steerWidth / 2) / scale;
        float ty = (y - steery) / scale;

        // Rotate by angle
        float rx = ca * tx + sa * ty + swtex.u + swtex.w / 2;
        float ry =-sa * tx + ca * ty + swtex.v + swtex.h / 2;

        // Draw textured line
        texlineh(textureImage, steerx - steerWidth / 2, y, steerWidth, rx, ry, 
             ca * swtex.w / steerWidth,
            -sa * swtex.h / steerWidth);
    }
    tran(-1);

    Texture ctex = gameTextures.steeringCenter;
    float centerWidth = ctex.w * scale;
    float centerHeight = ctex.h * scale;
    scaleTexture(ctex, steerx - centerWidth / 2, steery - centerHeight / 2,
        centerWidth, centerHeight);
}

void drawMirror() {

    int MIRROR_Y = 36 * PRATIO;
    int MIRROR_W = 150 * PRATIO;
    int MIRROR_H = 28 * PRATIO;

    float saveVanishY = vanishY;    
    vanishY = MIRROR_Y;

    bool isVisible = false;

    for (Car car : rearViewCars) {
        if (car.rearViewZ > 18) continue;

        if (not isVisible) {
            isVisible = true;
            color(race.track.skyColour);
            rectfill(
                SCREEN_WIDTH / 2 - MIRROR_W / 2,
                MIRROR_Y - MIRROR_H / 2,
                SCREEN_WIDTH / 2 + MIRROR_W / 2,
                MIRROR_Y + MIRROR_H / 2);
            clipregion(
                SCREEN_WIDTH / 2 - MIRROR_W / 2,
                MIRROR_Y - MIRROR_H / 2,
                SCREEN_WIDTH / 2 + MIRROR_W / 2,
                MIRROR_Y + MIRROR_H / 2);
        }

        Vec mirrorPos = new Vec {
            x = car.pos.x - player.pos.x,
            y = car.pos.y - player.pos.y,
            z = car.rearViewZ + 2.5
        };        
        Vec p = project(mirrorPos);
        float w = p.z * CAR_WIDTH;
        float h = p.z * CAR_WIDTH / 2;
        colmap(aiCarPalettes[car.carIndex]);
        scaleTexture(
            gameTextures.rearViewCar,
            p.x - w / 2, p.y - h / 2,
            w, h,
            false);
        colmap();
    }

    if (isVisible) {
        color(race.track.skyColour != 1 ? 1 : 0);
        rect(
            SCREEN_WIDTH / 2 - MIRROR_W / 2,
            MIRROR_Y - MIRROR_H / 2,
            SCREEN_WIDTH / 2 + MIRROR_W / 2,
            MIRROR_Y + MIRROR_H / 2);
        clipregion();
    }

    vanishY = saveVanishY;
}

void drawCarName(int[] palette, string name, int x, int y) {
    // Note: position is 0 index. So position 0 is first place etc.

    // Car icon
    if (palette != null) colmap(palette);
    scaleTexture(gameTextures.carIcon, x, y, 16 * PRATIO, 16 * PRATIO);
    colmap();

    // Car text
    print(name, x + 20 * PRATIO, y + 2 * PRATIO);
}

void drawCarName(Car car, int position, int x, int y) {
    drawCarName(
        car != player ? aiCarPalettes[car.carIndex] : null, 
        (position + 1) + placeText[min(position, 3)] + " " + car.name, 
        x, y);
}

void drawHud() {
    color(race.track.skyColour = 12 ? 3 : 12);

    // Simplified HUD during qualification
    if (race.isQualificationLap) {
        cursor(4 * PRATIO, 4 * PRATIO);
        print("Time" + formatTime(player.race.raceTime));
        return;
    }

    int CAR_NAME_X = SCREEN_WIDTH / 2 - 75 * PRATIO;

    // Find player car
    if (not race.isPracticeMode) {
        for (int i = 0; i < leaderboard.length; i++) {
            if (leaderboard[i] = player) {

                // Current place
                printScaled(i + 1, 0, 4 * PRATIO, 2 * PRATIO);
                print(placeText[min(i, 3)], 10 * PRATIO, 8 * PRATIO);

                // Car in front and behind
                if (i > 0) {
                    drawCarName(leaderboard[i - 1], i - 1, CAR_NAME_X, 1 * PRATIO);
                }
                if (i < leaderboard.length - 1) {
                    drawCarName(leaderboard[i + 1], i + 1, CAR_NAME_X, 12 * PRATIO);
                }            
            }
        }
    }

    // Current lap
    int lap = getLap(player.pos.z);
    string lapText = lap;
    int lapXOffset = race.isPracticeMode ? 0 : ((race.laps > 9 ? -12 : -6) - 6) * PRATIO;
    printScaled(lapText, SCREEN_WIDTH - (lapText.length * 6 + 8) * PRATIO + lapXOffset, 4 * PRATIO, 2 * PRATIO);
    print("Lap", SCREEN_WIDTH - 45 * PRATIO + lapXOffset, 4 * PRATIO);
    if (not race.isPracticeMode) {
        print("/" + race.laps, SCREEN_WIDTH - 2 * PRATIO + lapXOffset, 10 * PRATIO);
    }

    // Times
    if (race.isPracticeMode) {
        cursor(4 * PRATIO, 4 * PRATIO);
    }
    else {
        cursor(4 * PRATIO, 20 * PRATIO);
        print("Race" + formatTime(player.race.raceTime));
    }
    if (player.race.currentLapTime > 0) {
        print("Lap " + formatTime(player.race.currentLapTime));
    } 
    if (player.race.lastLapTime > 0) {
       print("Last" + formatTime(player.race.lastLapTime));    
    }
    if (player.race.bestLapTime > 0) {
       print("Best" + formatTime(player.race.bestLapTime));    
    }
}

void drawPreRaceText(string text) {
    int y = SCREEN_HEIGHT * 0.3;
    fancyPrint(text, 8, y, -1, 3, 1);
}

void drawResults() {
    
    int BOARD_WIDTH = (race.isQualificationLap ? 150 : 250) * PRATIO;
    int BOARD_HEIGHT = 115 * PRATIO;
    int BOARD_Y = 5 * PRATIO;
    int RESULTS_Y = BOARD_Y + 29 * PRATIO;
    int HEADING_Y = RESULTS_Y - 8 * PRATIO;
    int CAR_NAME_X = SCREEN_WIDTH / 2 - BOARD_WIDTH / 2 + 10 * PRATIO;
    int RACE_TIME_X = CAR_NAME_X + 115 * PRATIO;
    int LAP_TIME_X = RACE_TIME_X + 60 * PRATIO;
    color(0);
    rectfill(
        SCREEN_WIDTH/2 - BOARD_WIDTH/2,
        BOARD_Y,
        SCREEN_WIDTH/2 + BOARD_WIDTH/2,
        BOARD_Y + BOARD_HEIGHT);
    color(6);
    rect(
        SCREEN_WIDTH/2 - BOARD_WIDTH/2,
        BOARD_Y,
        SCREEN_WIDTH/2 + BOARD_WIDTH/2,
        BOARD_Y + BOARD_HEIGHT);

    if (not race.isQualificationLap) {
        fancyPrint("Final Standings", 10, BOARD_Y + 7 * PRATIO, -1, 1, 5);
        fancyPrint("Race Time", 7, HEADING_Y, RACE_TIME_X, 1, 5);
        fancyPrint("Best Lap", 7, HEADING_Y, LAP_TIME_X, 1, 5);
    }
    else {
        fancyPrint("Qualification Results", 10, BOARD_Y + 12, -1, 1, 5);    
    }

    int bestLap = 999999;
    int bestLapI = -1;
    for (int i = 0; i < raceResults.length; i++) {
        Car car = raceResults[i];
        if (car.race.bestLapTime > 0 and car.race.bestLapTime < bestLap) {
            bestLap = car.race.bestLapTime;
            bestLapI = i;
        }        
    }

    for (int i = 0; i < raceResults.length; i++) {
        Car car = raceResults[i];
        color(car = player ? 7 : 6);
        int y = RESULTS_Y + i * 10 * PRATIO;
        drawCarName(car, i, CAR_NAME_X, y);
        if (not race.isQualificationLap) {
            color(5);
            print(formatTime(car.race.raceTime, "0"), RACE_TIME_X, y + 2 * PRATIO);
            color(i = bestLapI ? 7 : 5);
            print(formatTime(car.race.bestLapTime, "0"), LAP_TIME_X, y + 2 * PRATIO);
        }
    }    
}

void doFadeOut() {
    fadeOut(colourPalette, FADE_OUT_TIME);
}

void fadeTransition() {
    doFadeOut();
    isFadeInScheduled = true;
}