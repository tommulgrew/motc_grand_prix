#include "stream"
#include "models"
#include "trackdata"

// Constants

const int TRACKSTREAMVERSION = 2;

const int CURVEFLAG_TURN			= 1;
const int CURVEFLAG_PITCH 			= 2;
const int CURVEFLAG_LEFT 			= 4;
const int CURVEFLAG_RIGHT 			= 8;
const int CURVEFLAG_LEFTBARRIER 	= 16;
const int CURVEFLAG_RIGHTBARRIER 	= 32;
const int CURVEFLAG_TREES 			= 64;
const int CURVEFLAG_DONTBRAKE 		= 128;

// Structures

struct TrackCurve {
	int length;
	int flags;
	float turn, pitch;
	int left, right;
	Model[] leftBarrier, rightBarrier;
	int[] trees;
	bool dontBrake;
	int z;					// Start distance along track (in segments)
}

struct TrackItem {
	Model model;
	Vec pos;
}

struct TrackStage {
	string name;
	TrackCurve[] curves;
	TrackItem[] items;
	int z;					// Start distance along track (in segments)
}

struct Track {
	string name;
	int finishLineDistance;
	TrackStage[] stages;
	int skyColour, groundColour;
	int randomSeed;
}

// Data
Track[] tracks = new Track[0];

// Routines

Model[] loadBarriers(Stream stream) {
	int count = load1(stream);
	Model[] barrierModels = new Model[0];
	for (int i = 0; i < count; i++) {
		int modelIndex = load1(stream) - 1;		// Model index is 1-origin in track data
		barrierModels.add(models[modelIndex]);			
	}
	return barrierModels;
}

int[] loadTrees(Stream stream) {
	int count = load1(stream);
	int[] trees = new int[0];
	for (int i = 0; i < count; i++) {
		trees.add(load1s(stream));
	}
	return trees;
}

TrackCurve loadTrackCurve(Stream stream) {
	TrackCurve curve = new TrackCurve;
	curve.length = load2(stream);
	curve.flags = load1(stream);
	if (curve.flags & CURVEFLAG_TURN 			!= 0) curve.turn 			= load2s(stream) / 100.0;
	if (curve.flags & CURVEFLAG_PITCH 			!= 0) curve.pitch 			= load1s(stream) / 100.0;
	if (curve.flags & CURVEFLAG_LEFT			!= 0) curve.left 			= load1s(stream);
	if (curve.flags & CURVEFLAG_RIGHT			!= 0) curve.right 			= load1s(stream);
	if (curve.flags & CURVEFLAG_LEFTBARRIER		!= 0) curve.leftBarrier		= loadBarriers(stream);
	if (curve.flags & CURVEFLAG_RIGHTBARRIER	!= 0) curve.rightBarrier	= loadBarriers(stream);
	if (curve.flags & CURVEFLAG_TREES			!= 0) curve.trees			= loadTrees(stream);
	curve.dontBrake = curve.flags & CURVEFLAG_DONTBRAKE != 0;

	return curve;
}

float curveTurn(TrackCurve curve, float def) {
	return curve.flags & CURVEFLAG_TURN != 0
		? curve.turn
		: def;
}

float curvePitch(TrackCurve curve, float def) {
	return curve.flags & CURVEFLAG_PITCH != 0
		? curve.pitch
		: def;
}

float curveLeft(TrackCurve curve, float def) {
	return curve.flags & CURVEFLAG_LEFT != 0
		? curve.left
		: def;
}

float curveRight(TrackCurve curve, float def) {
	return curve.flags & CURVEFLAG_RIGHT != 0
		? curve.right
		: def;
}

TrackItem loadTrackItem(Stream stream) {
	TrackItem item = new TrackItem;
	int modelIndex = load1(stream) - 1;		// Model index is 1-origin in track data
	item.model = models[modelIndex];
	item.pos = new Vec {
		x = load1s(stream),
		y = load1s(stream),
		z = load2(stream)
	};
	return item;
}

Track loadTrack(Stream stream, string name, int finishLineDistance) {
	Track track = new Track { 
		name = name,
		finishLineDistance = finishLineDistance,
		stages = new TrackStage[0]
	};

	// Version
	int v = load1(stream);
	assert(v = TRACKSTREAMVERSION, "Invalid track stream version: " + v + ", track: " + name);

	// Stages
	int stageCount = load1(stream);
	for (int si = 0; si < stageCount; si++) {
		TrackStage stage = new TrackStage {
			curves = new TrackCurve[0],
			items = new TrackItem[0]
		};

		// Name
		stage.name = loadString(stream);

		// Curves
		int curveCount = load1(stream);
		for (int ci = 0; ci < curveCount; ci++) {
			TrackCurve curve = loadTrackCurve(stream);			
			stage.curves.add(curve);
		}

		// Items
		int itemCount = load1(stream);
		for (int ii = 0; ii < itemCount; ii++) {
			TrackItem item = loadTrackItem(stream);
			stage.items.add(item);
		}

		track.stages.add(stage);	
	}

	track.skyColour = load1(stream);
	track.groundColour = load1(stream);

	return track;
}

// Deserialize tracks
for (int i = 0; i < trackData.length; i++) {
	Track track = loadTrack(
		new Stream { data = trackData[i] },
		trackNames[i],
		trackFinishlineDistances[i]);
	track.randomSeed = i + 12345;
	tracks.add(track);
}
