#include "tracks"
#include "models"

// Structures

const int REF_LEFT = 1;
const int REF_RIGHT = 2;

struct TrackItemInstance {
	Model model;
	Vec pos;
	int ref;
}

struct ModelInstance {
    Model model;
    Vec pos;                // World space position
    int ref;
    int length;
}

struct WorldSegment {
    float turn, pitch;
    float left, right;
    TrackStage stage;
    ModelInstance[] modelInstances;
    float aiVelocity;
}

// Data

WorldSegment[] world;
TrackCurve[] curves;

// Routines

void placeItem(Model model, Vec pos, int length = 0, int ref = 0) {
    
    // Place item for nested models
    for (NestedModel nested : model.nestedModels) {
        Vec nestedPos = pos;
        if (nested.pos != null) {
            pos += nested.pos;
        }
        placeItem(nested.model, nestedPos, length, ref);
    }

    if (not model.hasPolys) return;

    // Create model instance and assign to world segments
    int z = pos.z;
    z %= world.length;
    ModelInstance instance = new ModelInstance {
        model = model,
        pos = new Vec {
            x = pos.x, 
            y = pos.y,
            z = z
        },
        length = length,
        ref = ref
    };

    // Attach to world segments
    int effectiveLength = length > 0 ? length : model.segments.length;
    for (int i = 0; i < effectiveLength; i++) {
        WorldSegment segment = world[(z + i) % world.length];
        segment.modelInstances.add(instance);
    }
}

void placeItems(Track track) {
    for (TrackStage stage : track.stages) {
        for (TrackItem item : stage.items) {
            // Effective position
            Vec pos = new Vec {
                z = stage.z
            };
            if (item.pos != null) pos += item.pos;

            // Place track item
            placeItem(item.model, pos);
        }
    }
}

void generateTrackSegments(Track track) {
    world = new WorldSegment[0];
    curves = new TrackCurve[0];

    // Last curve determines start state for first curve
    TrackStage lastStage = track.stages[track.stages.length - 1];
    TrackCurve lastCurve = lastStage.curves[lastStage.curves.length - 1];
    float pitch = curvePitch(lastCurve, 0);
    float left = curveLeft(lastCurve, -4);
    float right = curveRight(lastCurve, 4);

    // Iterate stages and curves
    for (TrackStage stage : track.stages) {
        stage.z = world.length;
        for (TrackCurve curve : stage.curves) {
            curve.z = world.length;
            curves.add(curve);

            // Interpolate pitches and left/right
            float deltaPitch = 0, deltaLeft = 0, deltaRight = 0;
            if (curve.flags & CURVEFLAG_PITCH != 0) deltaPitch = (curve.pitch - pitch) / curve.length;
            if (curve.flags & CURVEFLAG_LEFT  != 0) deltaLeft  = (curve.left  - left)  / curve.length;
            if (curve.flags & CURVEFLAG_RIGHT != 0) deltaRight = (curve.right - right) / curve.length;

            // Generate world segments for curve
            for (int i = 0; i < curve.length; i++) {
                WorldSegment segment = new WorldSegment {
                    turn = curveTurn(curve, 0),
                    pitch = pitch,
                    left = left,
                    right = right,
                    stage = stage,
                    aiVelocity = 10,
                    modelInstances = new ModelInstance[0]
                };
                world.add(segment);

                // Apply deltas
                pitch += deltaPitch;
                left  += deltaLeft;
                right += deltaRight;
            }            
        }
    }
}

void placeBarrier(TrackCurve curve, Model[] barrier, int ref) {
    if (barrier != null) {
        for (Model barrierModel : barrier) {
            placeItem(
                barrierModel,
                new Vec { z = curve.z },
                curve.length,
                ref);
        }
    }
}

void generateTrees(TrackCurve curve, int[] treeXOffsets) {
    if (treeXOffsets != null) {
        for (int xOffset : treeXOffsets) {
            for (int z = 0; z < curve.length; z += 3) {
                float treeX = xOffset + rnd() * 4 - 2;
                Model model = treeModels[rnd() * treeModels.length];
                placeItem(
                    model,
                    new Vec {
                        x = treeX,
                        z = curve.z + z
                    });
            }
        }
    }
}

void generateRoadItems(Track track) {
    Model[] leftBarrier, rightBarrier;
    for (int i = 0; i < curves.length; i++) {
        TrackCurve prevCurve = curves[(i - 1 + curves.length) % curves.length];     // Must ensure index is non negative, due to % behaviour
        TrackCurve currentCurve = curves[i];
        TrackCurve nextCurve = curves[(i + 1) % curves.length];
        
        // Generate barriers
        if (currentCurve.leftBarrier != null) leftBarrier = currentCurve.leftBarrier;
        if (currentCurve.rightBarrier != null) rightBarrier = currentCurve.rightBarrier;
        placeBarrier(currentCurve, leftBarrier, REF_LEFT);
        placeBarrier(currentCurve, rightBarrier, REF_RIGHT);

        // Generate approaching corner signs
        if (abs(curveTurn(currentCurve, 0)) >= 0.1 and abs(curveTurn(prevCurve, 0)) < 0.01) {
            placeItem(distSignModel, new Vec { x = sgn(currentCurve.turn) * -5.5, z = currentCurve.z - 30 });
        }

        // Shoulder cover things
        if (currentCurve.length <= 12) {
            bool addLeft, addRight;
            for (TrackCurve curve : new TrackCurve[] { prevCurve, currentCurve, nextCurve }) {
                if (abs(curveTurn(curve, 0)) > 0.05) {
                    addLeft  = addLeft  or sgn(curve.turn) < 0;
                    addRight = addRight or sgn(curve.turn) > 0;
                }            
            }
            if (addLeft) {
                placeItem(shoulderModel, new Vec { x = -4, z = currentCurve.z }, currentCurve.length);
            }
            if (addRight) {
                placeItem(shoulderModel, new Vec { x =  4, z = currentCurve.z }, currentCurve.length);
            }
        }

        // Trees
        generateTrees(currentCurve, currentCurve.trees);
    }
}

void generateTrack(Track track) {
    generateTrackSegments(track);
    placeItem(roadModel, new Vec, world.length);
    generateRoadItems(track);
    // TODO: Road items
    placeItems(track);
    // TODO: AI X
    // TODO: AI velocity
}