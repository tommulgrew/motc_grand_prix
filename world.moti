#include "tracks"
#include "models"
#include "gameconstants"

// Structures

const int REF_LEFT  = 1;
const int REF_RIGHT = 2;

struct TrackItemInstance {
	Model model;
	Vec pos;
	int ref;
}

struct ModelInstance {
    Model model;
    Vec pos;                // World space position
    int ref;
    int length;
}

struct WorldSegment {
    float turn, pitch;
    float left, right;
    TrackStage stage;
    ModelInstance[] modelInstances;    
    float aiX, aiVelocity;
    bool hasAiX;
}

struct AICorner {       // A potential corner for AI X calculations
    int dir;
    int z;              // Start segment Z index
    int length;         // Total length (in segments)
    float turn;         // Total distance turned
}

// Data

WorldSegment[] world;
TrackCurve[] curves;

// Routines

float getWorldZ(float z) {
    return z - floor(z / world.length) * world.length;
}

int getSegmentIndex(float z) {
    return floor(getWorldZ(z));
}

Vec segmentRelativePos(Vec pos) {
    return pos - new Vec { z = floor(pos.z) };      // Position relative to segment
}

int getLap(float z) {
    return max(floor((z - race.track.finishLineDistance) / world.length), 0) + 1;
}

void placeItem(Model model, Vec pos, int length = 0, int ref = 0) {
    
    // Place item for nested models
    for (NestedModel nested : model.nestedModels) {
        Vec nestedPos = new Vec { x = pos.x, y = pos.y, z = pos.z };
        if (nested.pos != null) {
            nestedPos += nested.pos;
        }
        placeItem(nested.model, nestedPos, length, ref);
    }

    if (not model.hasPolys) return;

    // Create model instance and assign to world segments
    int z = pos.z;
    z %= world.length;
    ModelInstance instance = new ModelInstance {
        model = model,
        pos = new Vec {
            x = pos.x, 
            y = pos.y,
            z = z
        },
        length = length,
        ref = ref
    };

    // Attach to world segments
    int effectiveLength = length > 0 ? length : model.segments.length;
    for (int i = 0; i < effectiveLength; i++) {
        WorldSegment segment = world[(z + i) % world.length];
        segment.modelInstances.add(instance);
    }
}

void placeItems(Track track) {
    for (TrackStage stage : track.stages) {
        for (TrackItem item : stage.items) {
            // Effective position
            Vec pos = new Vec {
                z = stage.z
            };
            if (item.pos != null) pos += item.pos;

            // Apply random model set logic
            Model model = item.model;
            for (Model[] set : modelSets) {
                if (model = set[0]) {
                    model = set[rnd() * set.length];
                }
            }

            // Place track item
            placeItem(model, pos);
        }
    }
}

void generateTrackSegments(Track track) {
    world = new WorldSegment[0];
    curves = new TrackCurve[0];

    // Last curve determines start state for first curve
    TrackStage lastStage = track.stages[track.stages.length - 1];
    TrackCurve lastCurve = lastStage.curves[lastStage.curves.length - 1];
    float pitch = curvePitch(lastCurve, 0);
    float left = curveLeft(lastCurve, -4);
    float right = curveRight(lastCurve, 4);

    // Iterate stages and curves
    for (TrackStage stage : track.stages) {
        stage.z = world.length;
        for (TrackCurve curve : stage.curves) {
            curve.z = world.length;
            curves.add(curve);

            // Interpolate pitches and left/right
            float deltaPitch = 0, deltaLeft = 0, deltaRight = 0;
            if (curve.flags & CURVEFLAG_PITCH != 0) deltaPitch = (curve.pitch - pitch) / curve.length;
            if (curve.flags & CURVEFLAG_LEFT  != 0) deltaLeft  = (curve.left  - left)  / curve.length;
            if (curve.flags & CURVEFLAG_RIGHT != 0) deltaRight = (curve.right - right) / curve.length;

            // Generate world segments for curve
            for (int i = 0; i < curve.length; i++) {
                WorldSegment segment = new WorldSegment {
                    turn = curveTurn(curve, 0),
                    pitch = pitch,
                    left = left,
                    right = right,
                    stage = stage,
                    aiVelocity = 10,
                    modelInstances = new ModelInstance[0]
                };
                world.add(segment);

                // Apply deltas
                pitch += deltaPitch;
                left  += deltaLeft;
                right += deltaRight;
            }            
        }
    }
}

void placeBarrier(TrackCurve curve, Model[] barrier, int ref) {
    if (barrier != null) {
        for (Model barrierModel : barrier) {
            placeItem(
                barrierModel,
                new Vec { z = curve.z },
                curve.length,
                ref);
        }
    }
}

void generateTrees(TrackCurve curve, int[] treeXOffsets) {
    if (treeXOffsets != null) {
        for (int xOffset : treeXOffsets) {
            for (int z = 0; z < curve.length; z += 3) {
                float treeX = xOffset + rnd() * 4 - 2;
                Model model = gameModels.treeModels[rnd() * gameModels.treeModels.length];
                placeItem(
                    model,
                    new Vec {
                        x = treeX,
                        z = curve.z + z
                    });
            }
        }
    }
}

void generateRoadItems(Track track) {
    Model[] leftBarrier, rightBarrier;
    for (int i = 0; i < curves.length; i++) {
        TrackCurve prevCurve = curves[(i - 1 + curves.length) % curves.length];     // Must ensure index is non negative, due to % behaviour
        TrackCurve currentCurve = curves[i];
        TrackCurve nextCurve = curves[(i + 1) % curves.length];
        
        // Generate barriers
        if (currentCurve.leftBarrier != null) leftBarrier = currentCurve.leftBarrier;
        if (currentCurve.rightBarrier != null) rightBarrier = currentCurve.rightBarrier;
        placeBarrier(currentCurve, leftBarrier, REF_LEFT);
        placeBarrier(currentCurve, rightBarrier, REF_RIGHT);

        // Generate approaching corner signs
        if (abs(curveTurn(currentCurve, 0)) >= 0.1 and abs(curveTurn(prevCurve, 0)) < 0.01) {
            placeItem(gameModels.distSignModel, new Vec { x = sgn(currentCurve.turn) * -5.5, z = currentCurve.z - 30 });
        }

        // Shoulder cover things
        if (currentCurve.length <= 12) {
            bool addLeft, addRight;
            for (TrackCurve curve : new TrackCurve[] { prevCurve, currentCurve, nextCurve }) {
                if (abs(curveTurn(curve, 0)) > 0.05) {
                    addLeft  = addLeft  or sgn(curve.turn) < 0;
                    addRight = addRight or sgn(curve.turn) > 0;
                }            
            }
            if (addLeft) {
                placeItem(gameModels.shoulderModel, new Vec { x = -4, z = currentCurve.z }, currentCurve.length);
            }
            if (addRight) {
                placeItem(gameModels.shoulderModel, new Vec { x =  4, z = currentCurve.z }, currentCurve.length);
            }
        }

        // Trees
        generateTrees(currentCurve, currentCurve.trees);
    }
}

void addAIXVerts(Vec[] verts, AICorner corner) {
    // Check if corner turns enough to warrant a driving line
    if (corner != null and corner.turn >= 0.15) {
        float x = corner.dir * 2.5;

        // Place the apex in the center of the corner
        // Place the entry and exit points on the opposite side
        verts.add(new Vec { x = -x, z = corner.z - 10 });
        verts.add(new Vec { x =  x, z = corner.z + floor(corner.length / 2) });
        verts.add(new Vec { x = -x, z = corner.z + corner.length + 4 });
    }
}

void generateAIX(Track track) {
    Vec[] verts = new Vec[0];
    AICorner cornerCurve, currentCorner;
    for (TrackCurve c : curves) {

        // Potential corner?
        if (abs(c.turn) > 0.05) {
            cornerCurve = new AICorner {
                dir = sgn(c.turn),
                z = c.z,
                length = c.length,
                turn = abs(c.turn) * c.length
            };
        }
        else {
            cornerCurve = null;
        }

        // Add curve to current corner?
        if (currentCorner != null and cornerCurve != null and currentCorner.dir = cornerCurve.dir) {
            currentCorner.length += cornerCurve.length;
            currentCorner.turn += cornerCurve.turn;
        }
        else {
            // Add vertices for current corner (if any)
            addAIXVerts(verts, currentCorner);

            // Start new corner from curve
            currentCorner = cornerCurve;
        }
    }

    // Add vertices for last corner
    addAIXVerts(verts, currentCorner);

    // Write AI X values to road segments
    for (int i = 0; i < verts.length; i++) {
        Vec vert = verts[i];
        Vec nextVert = verts[(i + 1) % verts.length];
        int deltaZ = nextVert.z - vert.z;
        if (i == verts.length - 1) deltaZ += world.length;
        float x = vert.x;
        float xd = (nextVert.x - vert.x) / deltaZ;
        for (int j = 0; j < deltaZ; j++) {
            WorldSegment w = world[(toint(vert.z) + j) % world.length];
            if (w.hasAiX) {
                // Sometimes cornering lines can overlap.
                // Average them out when they do.
                w.aiX = (w.aiX + x) / 2;
            }
            else {
                w.aiX = x;
                w.hasAiX = true;
            }
            x += xd;
        }
    }

    // Smoothing pass
    float smoothedX = verts[verts.length - 1].x;
    for (WorldSegment w : world) {
        if (w.hasAiX) {
            smoothedX = smoothedX * 0.75 + w.aiX * 0.25;
        }
        w.aiX = smoothedX;
    }
}

void generateAIVelocity(Track track) {

    // Set all segments to "no limit"
    for (WorldSegment segment : world) {
        segment.aiVelocity = 1000;
    }

    // Lower speeds for curves
    for (TrackCurve c : curves) {
        float turn = abs(c.turn);
        DifficultyLevel difficulty = difficultyLevels[gameConfig.difficulty];
        if (turn > 0.01 and not (c.dontBrake and difficulty.applyDontBrake)) {

            // Calculate maximum velocity based on curvature.
            // Basically maximum speed before car will slide off the road.
            float maxv = sqrt(FRICTION_SIDE_SLIDE / (turn * VELOCITY_FACTOR)) * 0.9;
            for (int z = c.z - 3; z < c.z + c.length + 5; z++) {

                // Allow slightly faster speed limit when exiting curve
                float v = z < c.length / 2 ? maxv : maxv * 1.1;

                // Record against segment
                WorldSegment segment = world[(z + world.length) % world.length];
                segment.aiVelocity = min(segment.aiVelocity, v);
            }
        }
    }

    // Propagate speed limits backwards
    float i = world.length * 2;
    int prevIndex = 0;
    float v = 1000;
    while (i >= 0) {
        int segmentIndex = floor(i);
        WorldSegment segment = world[segmentIndex % world.length];
        if (segmentIndex != prevIndex) {
            v = min(segment.aiVelocity, v);
            segment.aiVelocity = v;
            prevIndex = segmentIndex;
        }

        // Solve quadratic formula to get maximum speed for previous segment
        // based on friction and braking rate.
        float a = -FRICTION_AIR, b = 1 - FRICTION_ROLL_ROAD, c = -BRAKE_RATE - v;
        float sqrtTerm = b*b - 4*a*c;
        if (sqrtTerm > 0) {
            v = (-b + sqrt(b*b - 4*a*c))/(2*a);
            i -= v * VELOCITY_FACTOR;
        }
        else {
            i--;
        }
    }
}

void generateTrack(Track track) {
    generateTrackSegments(track);
    placeItem(gameModels.roadModel, new Vec, world.length);
    generateRoadItems(track);
    placeItems(track);
    generateAIX(track);
    generateAIVelocity(track);
}